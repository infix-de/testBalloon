@file:OptIn(TestBalloonInternalApi::class)

package buildLogic

import de.infix.testBalloon.framework.shared.internal.Constants
import de.infix.testBalloon.framework.shared.internal.TestBalloonInternalApi
import de.infix.testBalloon.gradlePlugin.shared.TestBalloonGradleExtension
import de.infix.testBalloon.gradlePlugin.shared.TestBalloonGradleProperties
import de.infix.testBalloon.gradlePlugin.shared.compilerPluginOptionValues
import de.infix.testBalloon.gradlePlugin.shared.configureWithTestBalloon
import org.gradle.api.Project
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.UnknownConfigurationException
import org.jetbrains.kotlin.gradle.dsl.HasConfigurableKotlinCompilerOptions
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension
import org.jetbrains.kotlin.gradle.dsl.KotlinProjectExtension
import org.jetbrains.kotlin.gradle.plugin.NATIVE_COMPILER_PLUGIN_CLASSPATH_CONFIGURATION_NAME
import org.jetbrains.kotlin.gradle.plugin.PLUGIN_CLASSPATH_CONFIGURATION_NAME

/**
 * Adds the configuration normally supplied by the project's own Gradle plugin.
 *
 * This enables the project's compiler plugin without loading it from a repository.
 */
fun Project.addTestBalloonPluginFromProject(compilerPluginDependency: Dependency, sharedDependency: Dependency) {
    val testBalloonProperties = TestBalloonGradleProperties(this)

    with(dependencies) {
        add(PLUGIN_CLASSPATH_CONFIGURATION_NAME, compilerPluginDependency)
        try {
            add(NATIVE_COMPILER_PLUGIN_CLASSPATH_CONFIGURATION_NAME, compilerPluginDependency)
            // WORKAROUND https://youtrack.jetbrains.com/issue/KT-53477 â€“ KGP misses transitive compiler plugin
            //     dependencies
            add(NATIVE_COMPILER_PLUGIN_CLASSPATH_CONFIGURATION_NAME, sharedDependency)
        } catch (_: UnknownConfigurationException) {
            // The configuration "kotlinNativeCompilerPluginClasspath" is unavailable with AGP9's built-in Kotlin.
        }
    }

    val junitPlatformLauncherDependentConfigurationRegex =
        testBalloonProperties.junitPlatformLauncherDependentConfigurationRegex

    configurations.configureEach {
        if (junitPlatformLauncherDependentConfigurationRegex.containsMatchIn(name)) {
            dependencies.add(
                project.dependencies.create(libraryFromCatalog("org.junit.platform.launcher"))
            )
        }
    }

    configureWithTestBalloon(testBalloonProperties)

    // Set the compiler plugin options at a point in time where we can be sure that the testBalloon extension
    // has either been invoked, or will not ever be invoked.
    afterEvaluate {
        extensions.configure<KotlinProjectExtension>("kotlin") {
            val testBalloonExtension =
                extensions.getByName(Constants.GRADLE_EXTENSION_NAME) as TestBalloonGradleExtension
            val freeCompilerArgs = when (this) {
                is KotlinJvmProjectExtension -> compilerOptions.freeCompilerArgs
                is HasConfigurableKotlinCompilerOptions<*> -> compilerOptions.freeCompilerArgs
                else -> null
            }
            compilerPluginOptionValues(testBalloonExtension, testBalloonProperties).forEach { (key, value) ->
                freeCompilerArgs?.addAll("-P", "plugin:${Constants.COMPILER_PLUGIN_NAME}:$key=$value")
            }
        }
    }
}

/**
 * Extension accessor (outside this project, it is generated by Gradle).
 */
fun Project.testBalloon(action: TestBalloonGradleExtension.() -> Unit) {
    extensions.configure<TestBalloonGradleExtension>(Constants.GRADLE_EXTENSION_NAME) {
        action()
    }
}
