{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to TestBalloon","text":"<p>TestBalloon is a next generation Kotlin test framework, built from the ground up for Kotlin Multiplatform and coroutines.</p> <p>TestBalloon has a unique combination of characteristics which make it powerful, blazingly fast, and easy to use:</p> <ul> <li> State-of-the-art capabilities: Parameterized tests, multi-level hierarchy, coroutine context inheritance, deep parallelism, fixtures, expressive names, and a scope-friendly DSL-based API.</li> <li> Deep native integration with the platforms' existing APIs and build tooling, using the familiar Gradle tasks and Kotlin's own platform-specific test runtimes.</li> <li> Support for all Kotlin target platforms (JVM, JS, WebAssembly, Native(1), Android local tests, Android device tests).</li> </ul> <ol> <li>Native includes Linux, Windows, iOS, macOS and other Apple targets.</li> </ol> Kotlin MultiplatformAndroid DeviceAndroid Local <p> </p> <p> </p> <p> </p> <p>To find out more about why to use TestBalloon, look here.</p>"},{"location":"#documentation-overview","title":"Documentation Overview","text":"<p>This documentation is organized as follows:</p> <ul> <li>Getting started introduces TestBalloon's capabilities one by one.</li> <li>The How-to guide contains guidance about effective testing and migrating to TestBalloon.</li> <li>The API Reference provides comprehensive documentation for TestBalloon's public API.</li> </ul> <p>There are Support touchpoints and an incubating selection of Articles on TestBalloon.</p>"},{"location":"articles/","title":"Articles","text":"<p>Lifting Kotlin testing: Comparing JUnit, Kotlin-test, Kotest, Prepared and TestBalloon</p> <p>June 17, 2025 \u2013 Ivan \u201cCLOVIS\u201d Canet</p> <p>Ivan compares several aspects of current Kotlin test frameworks in great detail and concludes:</p> <p>Quote</p> <p>With the recent birth of TestBalloon, we can see that there is still a lot of innovating in the space of test frameworks. Even after JUnit's dominance in the JVM ecosystem, we can still make tests easier to write and maintain. Kotlin makes possible patterns that we couldn't dream of in the Java world. </p>"},{"location":"support/","title":"Support","text":"<p>You have questions, or you would like to discuss something?</p> <ul> <li> Join us in kotlinlang's #testballoon Slack channel.</li> </ul> <p>You have ideas, or found a bug?</p> <ul> <li> Visit TestBalloon's GitHub issue tracker.</li> </ul> <p>You need professional support?</p> <ul> <li> Get in touch: (click for e-mail address)</li> </ul>"},{"location":"getting-started/background/","title":"Background","text":"<p>Testing: the final frontier. These are the voyages of the TestBalloon framework. Its continuing mission: to explore strange new worlds; to seek out new bugs and new integrations; to boldly go where no one has gone before!</p> <p>If you\u2019d like to know why and how TestBalloon came to life, here is some background.</p> <p>You are wondering why TestBalloon works the way it does? Read about its design considerations.</p> <p>Finally, there is a brief introduction to development.</p> <p>For the curious:</p> <ul> <li>Read what needs to be considered when integrating with Kotlin-related build tooling and the IDE.</li> <li>Some details about Android platform support.</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/configuration/#introduction","title":"Introduction","text":"<p>TestBalloon provides two mechanisms to adapt the testing process to your needs via plain Kotlin:</p> <ol> <li> <p><code>TestSuite</code> extensions to register custom tests or test suites.</p> </li> <li> <p><code>TestConfig</code>, a uniform builder API to configure test elements at any level:</p> Single testTest suiteTest compartmentTest session <p></p> <p></p> <p></p> <p></p> </li> </ol> <p>Note</p> <p>TestBalloon aims to be as composable as possible with a simple but powerful API foundation. It is expected that users can more easily achieve their goals with a small amount of their own customization, rather than by using huge APIs and extension libraries.</p>"},{"location":"getting-started/configuration/#testsuite-extensions","title":"<code>TestSuite</code> extensions","text":"<p>To create reusable test variants, you can use extension functions on <code>TestSuite</code>.</p> <ul> <li> <p>A test with a timeout parameter, which also appears in the test's name:</p> <pre><code>fun TestSuite.test(\n    name: String,\n    timeout: Duration,\n    action: suspend TestExecutionScope.() -&gt; Unit\n) = test(\n    \"$name (timeout: $timeout)\",\n    testConfig = TestConfig.testScope(false)\n) {\n    try {\n        withTimeout(timeout) {\n            action()\n        }\n    } catch (cancellation: TimeoutCancellationException) {\n        throw AssertionError(\"$cancellation\", cancellation)\n    }\n}\n</code></pre> </li> <li> <p>A reusable test series:</p> <pre><code>fun TestSuite.testSeries(\n    name: String,\n    iterations: Int,\n    action: suspend TestExecutionScope.() -&gt; Unit\n) {\n    for (iteration in 1..iterations) {\n        test(\"$name $iteration\") {\n            action()\n        }\n    }\n}\n</code></pre> </li> <li> <p>A test providing a database resource as a context:</p> <pre><code>@TestRegistering // (1)!\nfun TestSuite.databaseTest(name: String, action: suspend Database.() -&gt; Unit) {\n    test(name) {\n        Database(this).use { // (2)!\n            it.action() // (3)!\n        }\n    }\n}\n</code></pre> <ol> <li>This annotation makes the IDE plugin aware of the non-standard method signature.</li> <li>Use a standard Kotlin scope function to safely close the resource after use.</li> <li>All test actions can now directly invoke database functions via <code>this</code>.</li> </ol> </li> </ul> <p>Using the same technique, you can create custom test suites, or test suite series.</p>"},{"location":"getting-started/configuration/#testconfig","title":"<code>TestConfig</code>","text":"<p>Use the <code>testConfig</code> parameter in conjunction with the <code>TestConfig</code> builder to configure any part of the test element hierarchy \u2013 your tests, test suites, up to global settings.</p> <pre><code>testSuite(\n    \"let's test concurrency\",\n    testConfig = TestConfig\n        .invocation(TestInvocation.CONCURRENT) // (1)!\n        .coroutineContext(dispatcherWithParallelism(4)) // (2)!\n        .statisticsReport() // (3)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>Use concurrent test execution instead of the sequential default.</li> <li>Parallelize as needed (and the platform supports).</li> <li>A custom configuration for extra reporting.</li> </ol>"},{"location":"getting-started/configuration/#custom-combinations","title":"Custom combinations","text":"<p>You can create a custom <code>TestConfig</code> extension combining the above configuration</p> <pre><code>fun TestConfig.onFourThreadsWithStatistics() = this // (1)!\n    .invocation(TestInvocation.CONCURRENT)\n    .coroutineContext(dispatcherWithParallelism(4))\n    .statisticsReport()\n</code></pre> <ol> <li>Starting with <code>this</code> enables <code>TestConfig</code> method chaining: You build on what was present before.</li> </ol> <p>and then reuse it as follows:</p> <pre><code>testSuite(\n    \"let's test concurrency\",\n    testConfig = TestConfig.onFourThreadsWithStatistics()\n) {\n    // ...\n}\n</code></pre>"},{"location":"getting-started/configuration/#custom-extensions","title":"Custom extensions","text":"<p>You can configure a custom <code>TestConfig</code> extension providing a test timeout:</p> <pre><code>fun TestConfig.withTestTimeout(timeout: Duration) = this // (1)!\n    .testScope(isEnabled = false) // (2)!\n    .aroundEachTest { action -&gt; // (3)!\n        try {\n            withTimeout(timeout) {\n                action()\n            }\n        } catch (cancellation: TimeoutCancellationException) {\n            throw AssertionError(\"$cancellation\", cancellation)\n        }\n    }\n</code></pre> <ol> <li>Starting with <code>this</code>, build on what was present before.</li> <li>Enable real time.</li> <li>Wrap around each test <code>action()</code>. By default, you must invoke it at some point, or configure an exception to that rule via <code>TestConfig.addPermits()</code>.</li> </ol> <p>The example in StatisticsReport.kt shows how to create a more complex custom <code>TestConfig</code> extension based on the existing <code>traversal</code> function.</p> <p>You'll be basing a custom extension on one or more existing <code>TestConfig</code> functions. The wrappers are good candidates:</p> <ul> <li><code>TestConfig.aroundAll</code></li> <li><code>TestConfig.aroundEach</code></li> <li><code>TestConfig.aroundEachTest</code></li> </ul> <p>The <code>TestConfig</code> API documentation provides a complete list.</p>"},{"location":"getting-started/configuration/#global-configuration","title":"Global configuration","text":"<p><code>TestSession</code> and <code>TestCompartment</code> are special types of <code>TestSuite</code> that form the top of the test element hierarchy. Like any other <code>TestElement</code>, they can be configured via <code>TestConfig</code>.</p>"},{"location":"getting-started/configuration/#test-compartments","title":"Test compartments","text":"<p>Tests may have different concurrency, isolation and environmental requirements. TestBalloon supports those via <code>TestCompartment</code>s. These group top-level test suites, with each compartment running in isolation.</p> <p>Info</p> <p>If you use compartments C1, C2, C3, TestBalloon will execute all tests in C1, then all tests in C2, then all tests in C3. The order is not determined, but the isolation between all tests in one compartment against tests in the other compartments is guaranteed.</p> <p>TestBalloon has a number of predefined compartments:</p> Predefined compartment Configuration of top-level test suites inside the compartment <code>TestCompartment.Concurrent</code> concurrent/parallel invocation <code>TestCompartment.Default</code> according to <code>TestSession</code>'s default configuration <code>TestCompartment.RealTime</code> sequential invocation, on a real-time dispatcher, without <code>TestScope</code> <code>TestCompartment.Sequential</code> sequential invocation (useful if <code>TestSession</code> is configured differently) <code>TestCompartment.MainDispatcher</code> sequential invocation, with access to a multiplatform <code>Main</code> dispatcher <p>You can use these, or create your own compartments.</p>"},{"location":"getting-started/configuration/#choosing-the-compartment-for-a-test-suite","title":"Choosing the compartment for a test suite","text":"<p>By default, every top-level test suite will be in the <code>TestSession</code>'s default compartment. Use the <code>testSuite</code> function's <code>compartment</code> parameter to put the test suite in a different compartment.</p> <pre><code>val RealTimeTests by testSuite(\n    compartment = { TestCompartment.RealTime } // (1)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol>"},{"location":"getting-started/configuration/#test-session","title":"Test session","text":"<p>The <code>TestSession</code> is a compilation module's root test suite, holding the module-wide default configuration.</p> <p>By default, TestBalloon uses a <code>TestSession</code> with a safe <code>TestSession.DefaultConfiguration</code> for all kinds of tests: It will</p> <ul> <li>execute test elements sequentially</li> <li>on <code>Dispatchers.Default</code>, and</li> <li>use <code>kotlinx.coroutines.test.TestScope</code> inside tests.</li> </ul>"},{"location":"getting-started/configuration/#customization","title":"Customization","text":"<p>You can specify your own test session by declaring a class deriving from <code>TestSession</code> inside the test compilation module it should affect.</p> <p>Tip</p> <p>If you want to reuse a custom test session class from a library, put a class deriving from the library's custom test session class into each of your test modules.</p> <p>To customize a <code>TestSession</code>, change its parameters from their defaults.</p> <p>The <code>testConfig</code> parameter defines the global configuration for the entire compilation module. This example extends the framework\u2019s default configuration:</p> <pre><code>class ModuleTestSession :\n    TestSession(testConfig = DefaultConfiguration.statisticsReport())\n</code></pre> <p>Alternatively, or additionally, you can change the test session's <code>defaultCompartment</code>.</p> <p>If all tests only mutate local state(1), you can speed up test execution greatly by choosing <code>TestCompartment.Concurrent</code>:</p> <ol> <li>Ascertain that tests do not share mutable state among each other and do not access global mutable state.</li> </ol> <pre><code>class ConcurrentTestSession :\n    TestSession(\n        defaultCompartment = { TestCompartment.Concurrent } // (1)!\n    )\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol>"},{"location":"getting-started/coroutines/","title":"Coroutines","text":""},{"location":"getting-started/coroutines/#structured-testing","title":"Structured testing","text":"<p>TestBalloon arranges test suites and tests in the test element hierarchy.</p> <p></p> <p>A test element hierarchy comprised of test suites and tests. Test compartments and the test session configure the top-level test suites.</p>"},{"location":"getting-started/coroutines/#context-inheritance","title":"Context inheritance","text":"<p>When tests execute, each test element (test, suite, compartment, session) has its own coroutine. The parent-child relationship between these coroutines is the same as between test elements. Coroutine contexts are inherited across the test element hierarchy.</p> <p>Note</p> <p>The coroutine hierarchy mirrors the test element hierarchy.</p>"},{"location":"getting-started/coroutines/#suspending-code","title":"Suspending code","text":"<p>During execution, code can suspend in (  blue code of)</p> <ul> <li>tests,</li> <li>test fixtures,</li> <li>execution wrappers.</li> </ul> <p>Info</p> <p>Code inside a test suite (which registers tests, suites, fixtures) cannot suspend. Registration is sequential. This enables consistent multiplatform integration, as lower-level test infrastructures require it.</p>"},{"location":"getting-started/coroutines/#deep-concurrency-and-parallelism","title":"Deep concurrency and parallelism","text":"<p>TestBalloon can be configured to execute tests concurrently or in parallel(1) at any level of the test hierarchy. This means that it can run all tests concurrently, or run selected tests concurrently and others sequentially.</p> <ol> <li>Parallel execution requires a multithreaded platform like the JVM, Native, or Android.</li> </ol> <p>Wherever TestBalloon runs tests concurrently, it does so with deep concurrency by default: It uses a common coroutine dispatcher to govern concurrency across the chosen parts of the test element hierarchy. This optimally distributes load across CPU cores.</p> <p>Note</p> <p>Contrast this with shallow concurrency, which parallelizes just the top-level, or complex parallelization schemes configured at different levels. These approaches create concurrency bottlenecks, leave CPUs underutilized, and thus cannot provide comparable throughput.</p> <p>Warning</p> <p>Never use the <code>maxParallelForks</code> option on Gradle test tasks. Gradle has no idea about the test structure and assumes class-based tests, which TestBalloon does not use.</p>"},{"location":"getting-started/coroutines/#testscope-by-default","title":"TestScope by default","text":"<p>All tests use kotlinx.coroutines' TestScope by default, including its virtual time and delay-skipping. A property <code>testScope</code> provides access to this <code>TestScope</code>.</p> <p>Info</p> <p><code>TestConfig.testScope</code> can configure the presence of a <code>TestScope</code> (and its timeout) for all or part of a test element hierarchy. You can always choose to execute your tests on a standard or custom dispatcher, and with real-time behavior.</p>"},{"location":"getting-started/examples/","title":"Examples","text":"<p>The TestBalloon repository contains examples covering typical use cases:</p> <ul> <li>TestBalloon\u2019s capabilities in general, including<ul> <li>parameterized (dynamic, data-driven) tests,</li> <li>fixtures (shared context),</li> <li>custom test variants,</li> <li>custom reports,</li> <li>concurrency,</li> <li>other configurations available via <code>TestConfig</code>.</li> </ul> </li> <li>Using TestBalloon for an Android app, containing<ul> <li>local tests (a.k.a. host-based tests, unit tests),</li> <li>device tests (a.k.a. instrumented tests),</li> <li>using JUnit 4 rules, and</li> <li>a Jetpack Compose UI test.</li> </ul> </li> <li>Using TestBalloon for a Kotlin Multiplatform project with an Android app, containing<ul> <li>local tests (a.k.a. host-based tests, unit tests),</li> <li>device tests (a.k.a. instrumented tests).</li> </ul> </li> <li>Using TestBalloon for a Kotlin Multiplatform plus Android library, containing<ul> <li>local (host-based, unit) tests,</li> <li>device (instrumented) tests.</li> </ul> </li> <li>Using TestBalloon with Kotest assertions.</li> </ul>"},{"location":"getting-started/first-steps/","title":"First steps","text":"<ol> <li> <p>Add the TestBalloon Gradle plugin to your build script:</p> <pre><code>plugins {\n    id(\"de.infix.testBalloon\") version \"$testBalloonVersion\"\n}\n</code></pre> </li> <li> <p>Add a dependency for the TestBalloon framework core library:</p> Kotlin MultiplatformKotlin JVM <pre><code>commonTest {\n    dependencies {\n        implementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n    }\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n}\n</code></pre> <p>Info</p> <p>The repository contains a Multiplatform configuration example.</p> </li> <li> <p>Add extra dependencies for Android (optional):</p> Kotlin Multiplatform with Android local testsKotlin Multiplatform with Android instrumented testsAndroid-only local testsAndroid-only instrumented tests <pre><code>androidUnitTest {\n    dependencies {\n        implementation(\"de.infix.testBalloon:testBalloon-framework-core-jvm:$testBalloonVersion\")\n    }\n}\n</code></pre> <pre><code>androidInstrumentedTest {\n    dependencies {\n        implementation(\"androidx.test:runner:$androidxRunnerVersion\")\n        implementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n    }\n}\n</code></pre> <pre><code>dependencies {\n    testImplementation(\"de.infix.testBalloon:testBalloon-framework-core-jvm:$testBalloonVersion\")\n}\n</code></pre> <pre><code>dependencies {\n    androidTestImplementation(\"androidx.test:runner:$androidxRunnerVersion\")\n    androidTestImplementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n}\n</code></pre> <p>Info</p> <p>The repository contains configuration examples for Android, Multiplatform with Android and Multiplatform library with Android.</p> <p>Note</p> <p>Google is deprecating the <code>com.android.application</code> plugin in favor of <code>com.android.kotlin.multiplatform.library</code>. Android-KMP integration is currently a moving target and there are multiple issues, so please test if it meets your needs.</p> </li> <li> <p>Add a dependency for the assertions library of your choice:</p> kotlin-test assertionsKotest assertions <pre><code>implementation(kotlin(\"test\"))\n</code></pre> <pre><code>implementation(\"de.infix.testBalloon:testBalloon-integration-kotest-assertions:$testBalloonVersion\")\n</code></pre> </li> <li> <p>Write a test:</p> <pre><code>val MyFirstTestSuite by testSuite {\n    test(\"string length\") {\n        assertEquals(8, \"Test me!\".length)\n    }\n}\n</code></pre> </li> <li> <p>Run tests via the familiar Gradle test tasks.</p> </li> <li> <p>Install the TestBalloon plugin for IntelliJ IDEA from the JetBrains Marketplace to run individual tests or test suites via the editor\u2019s gutter icons.</p> </li> </ol>"},{"location":"getting-started/fixtures/","title":"Fixtures (shared state)","text":"<p>A test fixture is a state holder. It initializes lazily on first use, and has a lifetime of the test suite it registers in.</p> <p>Note</p> <p>The fixture's value is accessed by invoking the fixture. This lets a fixture contain suspending setup code.</p> <pre><code>val StarredUsers by testSuite {\n    val starRepository = testFixture { // (1)!\n        StarRepository() // (2)!\n    } closeWith {\n        disconnect() // (3)!\n    }\n\n    test(\"alina\") {\n        assertEquals(4, starRepository().userStars(\"alina\")) // (4)!\n    }\n\n    test(\"peter\") {\n        assertEquals(3, starRepository().userStars(\"peter\")) // (5)!\n    }\n} // (6)!\n</code></pre> <ol> <li>Registers a test fixture with a lifetime of the enclosing test suite.</li> <li>The fixture's setup code can suspend.</li> <li>The fixture's (optional) tear-down code can suspend.</li> <li>The fixture initializes lazily on first use.</li> <li>The second test reuses the same fixture, sharing its setup cost and state.</li> <li>The fixture will close automatically when its suite finishes.</li> </ol> <p>Info</p> <p>If a fixture's value is an <code>AutoClosable</code>, the fixture will use its <code>close()</code> method, without requiring <code>closeWith</code>.</p>"},{"location":"getting-started/fixtures/#using-fixtures","title":"Using fixtures","text":"<p>With fixtures, you can create resource-intensive state once, reuse it in multiple tests, and rely on resources to be freed when they are no longer needed.</p> <p>Fixtures also support tests which build upon each other, sharing mutable state across tests.</p> <p>Tip</p> <p>With its default sequential execution, TestBalloon always runs tests in the order they appear in the source. This makes it easy to write tests which build upon each other.</p>"},{"location":"getting-started/integration/","title":"Integration","text":"<p>TestBalloon has a unified API for all Kotlin target platforms, residing in the <code>common</code> source set.</p> <p>Info</p> <p>TestBalloon integrates thoroughly with the platforms' existing APIs and build tooling, using the familiar Gradle tasks and Kotlin's own platform-specific test runtimes.</p> <p>TestBalloon supports multi-level nesting of test suites and deep concurrency on all platforms, even where the underlying infrastructure does not.</p> <p>Runtime information and environment variables are available on all platforms via the global <code>testPlatform</code> variable and its <code>TestPlatform</code> interface.</p> <p>The following sections provide an overview about TestBalloon's integration with its various platforms and build tooling. They are not meant to be exhaustive, but highlight selected details.</p>"},{"location":"getting-started/integration/#kotlin-multiplatform","title":"Kotlin Multiplatform","text":""},{"location":"getting-started/integration/#gradle","title":"Gradle","text":"<p>TestBalloon fully integrates with the Kotlin Gradle Plugin (Multiplatform or JVM). It supports</p> <ul> <li>the familiar Gradle and Kotlin test tasks,</li> <li>Gradle-based test filtering,</li> <li>Gradle's test reports (HTML and XML), and</li> <li>the Kotlin Gradle Plugin's combined multiplatform test reports.</li> </ul> <p>Warning</p> <p>Never use the <code>maxParallelForks</code> option on Gradle test tasks. Gradle has no idea about the test structure and assumes class-based tests, which TestBalloon does not use.</p>"},{"location":"getting-started/integration/#test-selection-filtering","title":"Test selection (filtering)","text":"<p>TestBalloon supports the usual Gradle test task filtering options for all Kotlin Multiplatform targets plus Android local (host-based) tests.(1)</p> <ol> <li>Android device (instrumented) tests do not use Gradle's filtering options since the AGP provides them as verification tasks, not test tasks.</li> </ol> <p>Test selection accepts the pipe <code>|</code> character to separate test elements. This is a valid test invocation:</p> <pre><code>./gradlew cleanJvmTest jvmTest --tests \"com.example.TestSuite|inner suite|*\" --no-build-cache --info\n</code></pre> <p>Alternatively, TestBalloon's own south-east arrow <code>\u2198</code> can be used, or a custom separator if the test patterns begins with one, like <code>;com.example.TestSuite;inner suite;*</code>.</p> <p>Warning</p> <p>IntelliJ IDEA's run configurations mess with test filtering via <code>--tests</code>. In this case, use the <code>TESTBALLOON_INCLUDE_PATTERNS</code> environment variable instead, like <code>TESTBALLOON_INCLUDE_PATTERNS=com.example.TestSuite|inner suite|*</code>.</p> <p>To use test selection with Android device (instrumented) tests, you have these options:</p> <ol> <li> <p>In the IDE's run configuration, use the instrumentation argument <code>TESTBALLOON_INCLUDE_PATTERNS</code> with the pattern as its value.</p> </li> <li> <p>Pass it via Gradle's command line:</p> <pre><code>./gradlew \"-Pandroid.testInstrumentationRunnerArguments.TESTBALLOON_INCLUDE_PATTERNS=com.example.TestSuite|inner suite|*\" ...\n</code></pre> </li> <li> <p>Use the Android Gradle DSL:</p> <pre><code>testInstrumentationRunnerArguments[\"TESTBALLOON_INCLUDE_PATTERNS\"] = \"com.example.TestSuite|inner suite|*\"\n</code></pre> </li> </ol>"},{"location":"getting-started/integration/#jvm","title":"JVM","text":"<p>TestBalloon registers with Gradle, without requiring any platform-specific configuration. TestBalloon can run alongside other JUnit-based test frameworks in the same module.</p> <p>TestBalloon supports deep concurrency and tests running in parallel.</p>"},{"location":"getting-started/integration/#js-wasmjs","title":"JS, Wasm/JS","text":"<p>TestBalloon fully supports the Kotlin Gradle Plugin's test infrastructure, including test execution via Node.js, or in a browser via Karma.</p> <p>TestBalloon supports deep concurrency on JS-based platforms, and provides simulated environment variables in browser tests.</p>"},{"location":"getting-started/integration/#browser-environment-variables","title":"Environment variables","text":"<p>TestBalloon exports only those environment variables into a browser's simulated environment, which are declared browser-safe. To do so, use these options (they are cumulative):</p> <ol> <li> <p>Set the Gradle property <code>testBalloon.browserSafeEnvironmentPattern</code> to a comma-separated list of environment variable names:</p> <pre><code>testBalloon.browserSafeEnvironmentPattern=CI|TEST.*\n</code></pre> </li> <li> <p>In a build script's <code>testBalloon</code> extension, set the parameter <code>browserSafeEnvironmentPattern</code>:</p> <pre><code>testBalloon {\n    browserSafeEnvironmentPattern = \"CI|TEST.*\"\n}\n</code></pre> </li> </ol>"},{"location":"getting-started/integration/#native","title":"Native","text":"<p>TestBalloon fully supports the Kotlin Gradle Plugin infrastructure.</p> <p>TestBalloon supports deep concurrency and tests running in parallel.</p>"},{"location":"getting-started/integration/#android","title":"Android","text":"<p>TestBalloon integrates with Android's test infrastructure, the Android Gradle Plugin (AGP), and the Android Gradle Library Plugin for KMP.</p>"},{"location":"getting-started/integration/#local-tests","title":"Local tests","text":"<p>TestBalloon supports Android local (host-based) tests via Android's JUnit 4 runner. Other (non-TestBalloon) JUnit-based tests can execute alongside TestBalloon in the same module.</p> <p>TestBalloon supports</p> <ul> <li>JUnit 4 test rules via its <code>testWithJUnit4Rule()</code> function,</li> <li>deep concurrency and tests running in parallel.</li> </ul>"},{"location":"getting-started/integration/#device-instrumented-tests","title":"Device (instrumented) tests","text":"<p>TestBalloon supports Android device tests via Android's JUnit 4 runner. Other (non-TestBalloon) JUnit-based tests can execute alongside TestBalloon in the same module.</p> <p>TestBalloon supports</p> <ul> <li>JUnit 4 test rules via its <code>testWithJUnit4Rule()</code> function,</li> <li>deep concurrency and tests running in parallel (on an emulator or a physical device).</li> </ul>"},{"location":"getting-started/integration/#android-device-environment-variables","title":"Environment variables","text":"<p>For Android device tests, TestBalloon provides simulated environment variables via instrumentation arguments. To set them, you have these options:</p> <ol> <li> <p>In the IDE's run configuration, use the instrumentation argument with the variable name and value.</p> </li> <li> <p>Pass it via Gradle's command line:</p> <pre><code>./gradlew \"-Pandroid.testInstrumentationRunnerArguments.VARIABLE_NAME=VALUE\" ...\n</code></pre> </li> <li> <p>Use the Android Gradle DSL:</p> <pre><code>testInstrumentationRunnerArguments[\"VARIABLE_NAME\"] = \"VALUE\"\n</code></pre> </li> </ol>"},{"location":"getting-started/integration/#intellij-idea","title":"IntelliJ IDEA","text":"<p>TestBalloon integrates with IntelliJ IDEA. Some of the functionality is provided by the TestBalloon plugin for IntelliJ IDEA.</p> <ul> <li>Editor windows show run gutter icons to run or debug individual tests or test suites (at any level).</li> <li>Test results appear in IntelliJ's test run window, including the results tree display.</li> <li>Stack traces in test results hide framework-internal lines by folding.</li> <li>Kotlin inspections allow title-case naming for TestBalloon's top-level suite properties.</li> </ul>"},{"location":"getting-started/integration/#limitations","title":"Limitations","text":"<p>Currently, TestBalloon's IntelliJ plugin does not support the following:</p> <ul> <li>Actions run, debug and jump to source in the test results tree display.</li> <li>Actions run, debug and jump to source for failed tests in the inspections window</li> <li>The action rerun failed tests in the test run window.</li> </ul>"},{"location":"getting-started/tests-and-suites/","title":"Tests and suites","text":""},{"location":"getting-started/tests-and-suites/#overview","title":"Overview","text":"<p>TestBalloon has a DSL-based API with two core functions: <code>testSuite</code> and <code>test</code>.</p> <ul> <li> <p>Tests are functions which either succeed or fail (throw). Tests contain your assertions. Code inside a test can suspend.</p> </li> <li> <p>Test suites structure your tests. They can nest across multiple levels. Code inside a test suite registers tests, test suites, and fixtures.</p> </li> <li> <p>You create top-level test suites as properties with a <code>by testSuite</code> delegation. TestBalloon will find them.</p> </li> </ul> <p>Tests and test suites accept strings as names.</p> <p>Note</p> <p>You have now learned TestBalloon's DSL API. The rest on this page is plain Kotlin.</p> <p>But please familiarize yourself with Green code and blue code and TestBalloon's golden rule.</p> <pre><code>val ExampleTests by testSuite { // (1)!\n    test(\"string length\") { // (2)!\n        assertEquals(8, \"Test me!\".length) // (3)!\n    }\n\n    testSuite(\"integer operations\") { // (4)!\n        test(\"max\") {\n            assertEquals(5, max(5, 3))\n        }\n\n        test(\"min\") {\n            delay(10.milliseconds) // (5)!\n            assertEquals(3, min(5, 3))\n        }\n    }\n}\n</code></pre> <ol> <li>Registers a top-level test suite. TestBalloon will automatically use the property's fully qualified name unless you provide an explicit name.</li> <li>Registers a test.</li> <li>An assertion from <code>kotlin-test</code>.</li> <li>Registers a nested test suite.</li> <li>A suspend function call.</li> </ol>"},{"location":"getting-started/tests-and-suites/#custom-functions-for-tests-and-test-suites","title":"Custom functions for tests and test suites","text":"<p>You can define your own types of tests and test suites, like this test variant with an <code>iterations</code> parameter:</p> <pre><code>fun TestSuite.test(\n    name: String,\n    iterations: Int,\n    action: suspend TestExecutionScope.() -&gt; Unit\n) = test(name) {\n    for (iteration in 1..iterations) {\n        action()\n    }\n}\n</code></pre> <p>Tip</p> <p>While the above code creates a custom test function, you can do the same with a test suite.</p> <p>Find more details under Configuration.</p>"},{"location":"getting-started/tests-and-suites/#parameterized-tests-and-test-suites","title":"Parameterized tests and test suites","text":"<p>In a test suite, you can use all Kotlin constructs (variable scopes, conditions, loops) to create tests and child test suites dynamically.</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre> <p>Parameterization works across test suites:</p> <pre><code>val UserTest by testSuite {\n    for (invalidUserName in listOf(\"\", \"a\", \"+\", \"+foo\")) {\n        testSuite(\"User name '$invalidUserName'\") {\n            for (role in User.Role.entries) {\n                test(\"is invalid with role '$role'\") {\n                    assertFailsWith&lt;IllegalArgumentException&gt; {\n                        User(invalidUserName, role)\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p> </p>"},{"location":"getting-started/tests-and-suites/#using-value-sources-generators","title":"Using value sources (generators)","text":"<p>Value sources help cover test edge cases and/or random samples without repetitive boilerplate code:</p> <pre><code>testSuite(\"Accepted counts\") {\n    val samples = buildList {\n        addAll(listOf(0, 1, Int.MAX_VALUE)) // (1)!\n        val randomSampleSource = Random(42) // (2)!\n        repeat(20) { add(randomSampleSource.nextInt(0, Int.MAX_VALUE)) }\n    }\n\n    for (count in samples) {\n        test(\"count $count is accepted\") {\n            service.updateTransactionCount(count) // should not throw\n        }\n    }\n}\n</code></pre> <ol> <li>Edge cases.</li> <li>Generating repeatable pseudo-random values with a seed.</li> </ol>"},{"location":"getting-started/tests-and-suites/#green-code-and-blue-code","title":"Green code and blue code","text":"<p>Info</p> <p>For a DSL-based framework, it is paramount to be aware of the effects of closures and variable capturing.</p>"},{"location":"getting-started/tests-and-suites/#runtime-phases","title":"Runtime phases","text":"<p>TestBalloon has two primary runtime phases:</p> <pre><code>graph LR\n    A(\"`**Test registration**&lt;br/&gt;(always sequential)`\") --&gt; B(\"`**Test execution**&lt;br/&gt;(sequential or concurrent)`\")</code></pre> <p>The  test registration phase is part of TestBalloon's setup: It creates the test element hierarchy, registering test suites, tests and fixtures, and configuring test elements. At the end, it knows exactly what to run. (1)</p> <ol> <li>TestBalloon is fast to register tests. It can register and configure 1.7 million tests in 7 seconds on a decent Laptop. It also knows shortcuts if only parts of the test element hierarchy have been selected.</li> </ol> <p>Info</p> <p>The   test registration phase always completes before the  test execution phase starts.</p> <p>The  test execution phase is where the action is. While the default is to run tests sequentially, concurrent execution can be configured at any level of the test element hierarchy.</p>"},{"location":"getting-started/tests-and-suites/#blue-code-registration-phase","title":"Blue code (registration phase)","text":"<p>In TestBalloon, all code outside the lambdas of tests, fixtures and execution wrappers is registration-phase code, or  blue code:</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/tests-and-suites/#green-code-execution-phase","title":"Green code (execution phase)","text":"<p>Code inside the lambdas of tests, fixtures and execution wrappers is execution-phase code, or  green code:</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/tests-and-suites/#testballoons-golden-rule","title":"TestBalloon's golden rule","text":"<p>With power comes some responsibility. The golden rule is:</p> <p>Danger</p> <p>Never leak mutable state from   blue code into  green code.</p> <p>Why is this important?</p>"},{"location":"getting-started/tests-and-suites/#this-breaks","title":"\u274c This breaks","text":"<pre><code>testSuite(\"Broken calculator test suite\") {\n    val calculator = Calculator()\n    val operands = listOf(7, 23, 15)\n    var sum = 0 // (1)\n\n    for (operand in operands) {\n        sum += operand // (2)\n        test(\"add $operand, expect $sum\") {\n            calculator.add(operand)\n            assertEquals(sum, calculator.result) // (3)\n        }\n    }\n}\n</code></pre> <ol> <li><code>sum</code> is mutable state.</li> <li><code>sum</code> is mutated in blue code.</li> <li><code>sum</code> leaks into green code.</li> </ol> <p>The above code will produce failing tests:</p> <p> </p> <p>Why? All the additions to <code>sum</code> occurred in blue code before any green code would start. So green code inside tests can only see the latest blue-code state of <code>sum</code>, which is 45.</p>"},{"location":"getting-started/tests-and-suites/#this-works","title":"\u2705 This works","text":"<pre><code>testSuite(\"Healthy calculator test suite\") {\n    val calculator = Calculator()\n    val operandsAndSums = buildList { // (1)\n        val operands = listOf(7, 23, 15)\n        var sum = 0\n        for (operand in operands) {\n            sum += operand\n            add(operand to sum)\n        }\n    }\n\n    for ((operand, sum) in operandsAndSums) {\n        test(\"add $operand, expect $sum\") {\n            calculator.add(operand) // (2)\n            assertEquals(sum, calculator.result) // (3)\n        }\n    }\n}\n</code></pre> <ol> <li>Blue code contains immutable state only.</li> <li>Well, not entirely: The calculator is mutable. This works, because it is not mutated in blue code, but only in green code.</li> <li>Using immutable state originating in blue code is safe.</li> </ol> <p>Here, all operands and expected <code>sum</code> values were created as immutable state in blue code. This is always safe.</p> <p>Info</p> <p>State leaks with closures, which run later or concurrently, can happen anywhere (flows, sequences, coroutines, anything lazy). For this reason, YouTrack issue KT-15514 suggests to make the compiler emit a warning in such cases.</p>"},{"location":"how-to/effective-testing/","title":"Effective testing","text":"<p>Using TestBalloon's powers, how can we test better with less effort? This section offers guidance for typical scenarios.</p>"},{"location":"how-to/effective-testing/#expressive-names","title":"Expressive names","text":"<p>Make tests communicate their purpose:</p> <pre><code>test(\"User '$user' must be signed in\") {\n    // ...\n}\n</code></pre>"},{"location":"how-to/effective-testing/#write-once-test-many","title":"Write once, test many","text":"<p>Let immutable state describe and drive your test cases:</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre>"},{"location":"how-to/effective-testing/#cover-edge-cases-and-samples","title":"Cover edge cases and samples","text":"<p>Test edge cases and/or random samples with value sources (generators):</p> <pre><code>testSuite(\"Accepted counts\") {\n    val samples = buildList {\n        addAll(listOf(0, 1, Int.MAX_VALUE)) // (1)!\n        val randomSampleSource = Random(42) // (2)!\n        repeat(20) { add(randomSampleSource.nextInt(0, Int.MAX_VALUE)) }\n    }\n\n    for (count in samples) {\n        test(\"count $count is accepted\") {\n            service.updateTransactionCount(count) // should not throw\n        }\n    }\n}\n</code></pre> <ol> <li>Edge cases.</li> <li>Generating repeatable pseudo-random values with a seed.</li> </ol> <p>One test per sample documents which tests were actually run:</p> <p> </p>"},{"location":"how-to/effective-testing/#supply-fresh-state-to-multiple-tests","title":"Supply fresh state to multiple tests","text":"<p>Suppose a number of tests needs fresh state like this:</p> <pre><code>val service = Service().apply {\n    signIn(userName = \"siobhan\", password = \"ask\") // (1)!\n}\n</code></pre> <ol> <li>Note that <code>signIn</code> can be a suspending function.</li> </ol> <p>To conveniently provide each test with that fresh state, available as a context via <code>this</code>, define a custom DSL function:</p> <pre><code>testSuite(\"Multiple tests with fresh state\") {\n    @TestRegistering // (2)!\n    fun test(name: String, action: suspend Service.() -&gt; Unit) = // (3)!\n        this.test(name) {\n            val service = Service().apply {\n                signIn(userName = \"siobhan\", password = \"ask\") // (1)!\n            }\n            service.action() // (4)!\n            // cleanup...\n        }\n\n    test(\"deposit\") {\n        deposit(Amount(20.0)) // (5)!\n        assertEquals(Amount(40.99), accountBalance()) // (6)!\n    }\n\n    test(\"withdraw\") {\n        withdraw(Amount(20.0))\n        assertEquals(Amount(0.99), accountBalance())\n    }\n}\n</code></pre> <ol> <li><code>signIn</code> can be a suspending function.</li> <li>Tell the IDE plugin to put test run gutters at the function's call sites.</li> <li>Redefine the <code>test()</code> function locally to use a service as an extension receiver.</li> <li>Provide the context to each test action.</li> <li><code>deposit()</code> is a method of the <code>Service</code> extension receiver.</li> <li><code>accountBalance()</code> is a method of the <code>Service</code> extension receiver.</li> </ol> <p>Tip</p> <p>In this case, tests are fully isolated from each other. They are ideal candidates for concurrent execution.</p>"},{"location":"how-to/effective-testing/#use-shared-state-across-multiple-tests","title":"Use shared state across multiple tests","text":"<p>To conveniently share state among tests, use a fixture and define a custom DSL function providing it as a context:</p> <pre><code>testSuite(\"Multiple tests sharing state\") {\n    class Context { // (1)!\n        val service = Service().apply {\n            signIn(userName = \"siobhan\", password = \"ask\")\n        }\n        var expectedTransactionCount = 0 // (2)!\n    }\n\n    val context = testFixture { Context() }\n\n    @TestRegistering // (3)!\n    fun test(name: String, action: suspend Context.() -&gt; Unit) = // (4)!\n        this.test(name) { context().action() } // (5)!\n\n    test(\"deposit\") {\n        service.deposit(Amount(20.0))\n        assertEquals(Amount(40.99), service.accountBalance())\n        assertEquals(++expectedTransactionCount, service.transactionCount())\n    }\n\n    test(\"withdraw\") {\n        service.withdraw(Amount(20.0))\n        assertEquals(Amount(20.99), service.accountBalance())\n        assertEquals(++expectedTransactionCount, service.transactionCount())\n    }\n}\n</code></pre> <ol> <li>Use a local class to define a test-specific context.</li> <li>We can use mutable state here. This is green code which exists exclusively at test execution time, preserving TestBalloon's golden rule.</li> <li>Tell the IDE plugin to put test run gutters at the function's call sites.</li> <li>Redefine the test function locally to use the test-specific context.</li> <li>Provide the fixture as a context to each test action.</li> </ol> <p>Tip</p> <p>Writing tests that build on each other is easy, because, by default, TestBalloon runs tests in the order they appear in the source. Just make sure that you don't configure concurrent execution for them.</p>"},{"location":"how-to/effective-testing/#make-tests-run-fast","title":"Make tests run fast","text":""},{"location":"how-to/effective-testing/#if-all-tests-avoid-non-local-mutable-state","title":"\u2026if all tests avoid non-local mutable state","text":"<p>If you have a module where all tests only mutate local state(1), you can speed up test execution greatly by running them concurrently. To do so, put this declaration anywhere in your test module:</p> <ol> <li>Ascertain that tests do not share mutable state among each other and do not access global mutable state.</li> </ol> <pre><code>class ConcurrentTestSession :\n    TestSession(\n        defaultCompartment = { TestCompartment.Concurrent } // (1)!\n    )\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol>"},{"location":"how-to/effective-testing/#if-most-tests-avoid-non-local-mutable-state","title":"\u2026if most tests avoid non-local mutable state","text":"<ol> <li> <p>Configure the module's test session for concurrency:</p> <pre><code>class ConcurrentTestSession :\n    TestSession(\n        defaultCompartment = { TestCompartment.Concurrent } // (1)!\n    )\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol> </li> <li> <p>Put top-level test suites, whose test's access non-local mutable state, in the predefined <code>Sequential</code> compartment:</p> <pre><code>val TestsSharingMutableState by testSuite(\n    compartment = { TestCompartment.Sequential } // (1)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol> </li> </ol> <p>TestBalloon will now execute tests in the <code>Sequential</code> compartment sequentially, and also isolate them from all concurrent tests.</p>"},{"location":"how-to/effective-testing/#if-only-some-tests-can-run-concurrently","title":"\u2026if only some tests can run concurrently","text":"<p>Put top-level test suites, whose test's can run concurrently, in the predefined <code>Concurrent</code> compartment:</p> <pre><code>val ConcurrentTests by testSuite(\n    compartment = { TestCompartment.Concurrent } // (1)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol> <p>TestBalloon will now execute most tests sequentially (by default), and isolate them from those in the <code>Concurrent</code> compartment, which run concurrently.</p>"},{"location":"how-to/effective-testing/#a-ui-test-with-jetpack-compose","title":"A UI test with Jetpack Compose","text":"<p>TestBalloon does not bundle Compose dependencies, but it does provide a <code>testWithJUnit4Rule()</code> function. With that, you can create a custom DSL function:</p> <pre><code>@TestRegistering\n@OptIn(TestBalloonExperimentalApi::class) // required for testWithJUnit4Rule\nfun TestSuite.composeTest(\n    name: String,\n    composeTestRule: ComposeContentTestRule = createComposeRule(),\n    action: suspend ComposeTestContext&lt;ComposeContentTestRule&gt;.() -&gt; Unit\n) = testWithJUnit4Rule(name, composeTestRule) {\n    ComposeTestContext(composeTestRule).action()\n}\n\nclass ComposeTestContext&lt;Rule&gt;(val composeTestRule: Rule)\n</code></pre> <p>Having done this, you can use Jetpack Compose tests inside TestBalloon via <code>composeTestRule</code>, as shown in the Google documentation:</p> <pre><code>val JetpackComposeTests by testSuite {\n    composeTest(\"click\") {\n        composeTestRule.setContent {\n            ComposableUnderTest()\n        }\n\n        composeTestRule.onNodeWithText(\"Button\").performClick()\n        composeTestRule.onNodeWithText(\"Success\").assertExists()\n    }\n}\n</code></pre> <p>For a complete example, see Jetpack Compose UI test.</p>"},{"location":"how-to/effective-testing/#a-ui-test-with-compose-multiplatform","title":"A UI test with Compose Multiplatform","text":"<p>Compose Multiplatform provides an experimental <code>runComposeUiTest()</code> API. To use it with TestBalloon, create a custom DSL function like this:(1)</p> <ol> <li>Using the Compose Multiplatform test API requires an opt-in directive like <code>@file:OptIn(ExperimentalTestApi::class)</code>.</li> </ol> <pre><code>@TestRegistering\nfun TestSuite.composeTest(name: String, action: suspend ComposeUiTest.() -&gt; Unit) = test(name) {\n    @OptIn(TestBalloonExperimentalApi::class) // required for TestBalloon's testTimeout\n    runComposeUiTest(\n        runTestContext = coroutineContext.minusKey(CoroutineExceptionHandler.Key),\n        testTimeout = testTimeout ?: 60.seconds\n    ) {\n        action()\n    }\n}\n</code></pre> <p>With that, you can use Compose Multiplatform tests inside TestBalloon as shown in the JetBrains documentation.(1)</p> <ol> <li>Using the Compose Multiplatform test API requires an opt-in directive like <code>@file:OptIn(ExperimentalTestApi::class)</code>.</li> </ol> <pre><code>val ComposeMultiplatformTests by testSuite {\n    composeTest(\"click\") {\n        setContent {\n            ComposableUnderTest()\n        }\n\n        onNodeWithText(\"Button\").performClick()\n        onNodeWithText(\"Success\").assertExists()\n    }\n}\n</code></pre>"},{"location":"how-to/effective-testing/#handling-flaky-tests","title":"Handling flaky tests","text":"<p>One way of handling flaky tests is to repeat them until they succeed.</p> <p>Create a <code>TestConfig</code> extension:</p> <pre><code>fun TestConfig.repeatOnFailure(maxRepetitions: Int) = aroundEachTest { action -&gt;\n    var lastException: Throwable? = null\n    repeat(maxRepetitions) {\n        try {\n            action()\n            return@aroundEachTest\n        } catch (exception: Throwable) {\n            lastException = exception\n            // suppress as long as we try repeatedly\n        }\n    }\n    throw lastException!!\n}\n</code></pre> <p>Use it like this:</p> <pre><code>val FlakyTests by testSuite {\n    testSuite(\"not controlled\") {\n        test(\"would succeed after 3 failures\") {\n            doSomethingFlaky()\n        }\n    }\n\n    testSuite(\"under control\", testConfig = TestConfig.repeatOnFailure(5)) {\n        test(\"succeeds after 3 failures\") {\n            doSomethingFlaky()\n        }\n\n        test(\"always fails\") {\n            throw Error(\"always failing\")\n        }\n    }\n}\n</code></pre> <p>The outcome:</p> <p> </p>"},{"location":"how-to/effective-testing/#conditional-tag-based-testing","title":"Conditional tag-based testing","text":"<p>TestBalloon provides the option of using environment variables to control test execution on all Kotlin targets.(1)</p> <ol> <li>JS browsers and Android (emulated or physical) devices do not natively support environment variables. TestBalloon provides a (simulated) environment for those. For Android device tests, you need to set them via instrumentation arguments. For JS browsers, you need to declare them as browser-safe.</li> </ol> <p>If you define tags(1) and a <code>TestConfig</code> extension like this,</p> <ol> <li>These are your tags, literally, in plain Kotlin, instead of some complex pre-defined tag regime.</li> </ol> <pre><code>enum class MyTag {\n    CI,\n    SimulatedCI,\n    Release;\n\n    fun value() =\n        testPlatform.environment(\"TEST_TAGS\")?.split(',')?.last { it == name }\n\n    fun exists() = value() != null\n}\n\nfun TestConfig.onlyIfTagged(vararg tags: MyTag) =\n    if (tags.any { it.exists() }) this else disable()\n</code></pre> <p>\u2026you can use a <code>TEST_TAGS</code> environment variable to conditionally run tests and suites at any level of the test element hierarchy:</p> <pre><code>val ConditionalTests by testSuite(\n    testConfig = TestConfig.onlyIfTagged(MyTag.CI, MyTag.SimulatedCI)\n) {\n    // ...\n}\n</code></pre>"},{"location":"overview/why/","title":"Why use TestBalloon?","text":""},{"location":"overview/why/#unique","title":"Unique","text":"<p>TestBalloon combines</p> <ul> <li> state-of-the-art capabilities(1) with</li> <li> deep native integration(2)</li> <li> on all platforms.(3)</li> </ul> <ol> <li>Parameterized tests, multi-level hierarchy, coroutine context inheritance, deep parallelism, fixtures, expressive names, and a scope-friendly DSL-based API.</li> <li>TestBalloon integrates thoroughly with the platforms' existing APIs and build tooling, using the familiar Gradle tasks and Kotlin's own platform-specific test runtimes.</li> <li>TestBalloon supports all Kotlin target platforms (JVM, JS, WebAssembly, Android local tests, Android device tests, Linux, Windows, iOS, macOS and other Apple targets).</li> </ol>"},{"location":"overview/why/#empowering","title":"Empowering","text":"<p>TestBalloon helps you lift product quality, save time and actually make testing enjoyable.</p> <ul> <li> Write better tests (parameterize them)</li> <li> with less effort (using your Kotlin skills and a simple API)</li> <li> on all platforms (with native integration that just works).</li> </ul> <p>What else?</p> <ul> <li> Stay organized (with expressive names and a multi-level hierarchy),</li> <li> get faster results (with deep parallelism in test runs),</li> <li> remain compatible (with all Kotlin releases since 2.0).</li> </ul>"},{"location":"overview/why/#robust","title":"Robust","text":"<p>TestBalloon consists of production-quality code and has been intensively tested. Its own test suite runs all component tests on all Kotlin targets, plus integration tests on all Kotlin target categories.</p>"},{"location":"overview/why/#fast","title":"Fast","text":"<p>TestBalloon can cover large test sets and has been observed running 1.7 million real-world tests in 86 seconds on a Framework 13 Laptop (18 cores, 4 GB JVM heap) with concurrent execution enabled.</p>"},{"location":"overview/why/#production-ready","title":"Production-ready","text":"<p>TestBalloon is actively used in production.</p> <p>Open source products using TestBalloon include:</p> <ul> <li> Prepared \u2013 a Kotlin Multiplatform test library featuring time management, parameterization and isolated fixtures</li> <li> Signum \u2013 a Kotlin Multiplatform crypto/PKI library and ASN1 parser + encoder</li> <li> VC-K \u2013 a verifiable credentials library for Kotlin Multiplatform</li> <li> Warden Supreme \u2013 an integrated key and app attestation suite</li> </ul> <p>Of course, advanced testing is often found in closed-source products, and TestBalloon is in active use there as well.</p>"},{"location":"overview/why/#stability","title":"Stability","text":"<p>TestBalloon has a stable feature set. However, it is still evolving, so you should expect some migration issues. Breaking changes will be documented in the release notes, along with migration guidance.</p>"},{"location":"overview/why/#why-wait","title":"Why wait?","text":"<p>TestBalloon is your trouble reducer and helps you release with confidence.</p> <ul> <li> Powerful multiplatform testing made easy.</li> <li> Test more (edge) cases with less effort.</li> <li> Keep your AI-generated code in check.</li> </ul>"}]}