{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to TestBalloon","text":"<p>TestBalloon is a next generation Kotlin test framework, built from the ground up for Kotlin Multiplatform and coroutines.</p> <p>TestBalloon has a unique combination of characteristics which make it powerful, blazingly fast, and easy to use:</p> <ul> <li> State-of-the-art capabilities: Parameterized tests, multi-level hierarchy, coroutine context inheritance, deep parallelism, fixtures, expressive names, and a scope-friendly DSL-based API.</li> <li> Deep native integration with the platforms' existing APIs and build tooling, using the familiar Gradle tasks and Kotlin's own platform-specific test runtimes.</li> <li> Support for all Kotlin target platforms (JVM, JS, WebAssembly, Native(1), Android host-side tests, Android device-side tests).</li> </ul> <ol> <li>Native includes Linux, Windows, iOS, macOS and other Apple targets.</li> </ol> Kotlin MultiplatformAndroid DeviceAndroid Host <p> </p> <p> </p> <p> </p> <p>To find out more about why to use TestBalloon, look here.</p>"},{"location":"#documentation-overview","title":"Documentation Overview","text":"<p>This documentation is organized as follows:</p> <ul> <li>Getting started introduces TestBalloon's capabilities one by one.</li> <li>The How-to guide contains guidance about effective testing and migrating to TestBalloon.</li> <li>The API Reference provides comprehensive documentation for TestBalloon's public API.</li> </ul> <p>In addition, there are Support touchpoints and a Blog covering TestBalloon developments.</p>"},{"location":"support/","title":"Support","text":"<p>You have questions, or you would like to discuss something?</p> <ul> <li> Join us in kotlinlang's #testballoon Slack channel.</li> </ul> <p>You have ideas, or found a bug?</p> <ul> <li> Visit TestBalloon's GitHub issue tracker.</li> </ul> <p>You need professional support?</p> <ul> <li> Get in touch: (click for e-mail address)</li> </ul>"},{"location":"blog/2025/06/17/lifting-kotlin-testing-comparing-junit-kotlin-test-kotest-prepared-and-testballoon/","title":"Lifting Kotlin testing: Comparing JUnit, Kotlin-test, Kotest, Prepared and TestBalloon","text":"<p>Published on June 17, 2025 by Ivan \u201cCLOVIS\u201d Canet</p> <p>Ivan compares several aspects of current Kotlin test frameworks in great detail and concludes:</p> <p>Quote</p> <p>With the recent birth of TestBalloon, we can see that there is still a lot of innovating in the space of test frameworks. Even after JUnit's dominance in the JVM ecosystem, we can still make tests easier to write and maintain. Kotlin makes possible patterns that we couldn't dream of in the Java world. </p> <p>Read the full article (external site).</p>"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/","title":"Roboelectric meets TestBalloon","text":"<p>GenAI said it would be impossible:</p> <p>This integration is not feasible with the current TestBalloon architecture without significant changes to the compiler plugin or framework core.</p> <p>Yet here it is \u2013 no significant changes, just an integration built with the public TestBalloon API.</p>"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#so-what-do-we-have","title":"So what do we have?","text":"<p>Roboelectric brings fast, reliable and configurable Android tests to the JVM. It lets us operate close to the real device without waiting for dexing, packaging, installing and emulator start-up.</p> <p>TestBalloon adds easily parameterized tests, nested test suites, test fixtures, and a Roboelectric environment that can be fully configured in plain Kotlin, using a DSL, avoiding the restrictions of annotations.</p>"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#an-example","title":"An example","text":"<p>To test our app's rendering on a set of display formats combined with several Android API levels, we'd write:</p> <pre><code>val RenderingTests by testSuite {\n    for (display in listOf(\"xlarge-port\", \"xlarge-land\")) {\n        for (apiLevel in listOf(36, 34, 28)) {\n            roboelectricTestSuite( // (1)!\n                \"Display: $display, API $apiLevel\",\n                RenderingTestSuiteContent::class, // (2)!\n                testConfig = TestConfig.roboelectric { // (3)!\n                    sdk = apiLevel\n                    qualifiers = display\n                }\n            ) // (4)!\n        }\n    }\n}\n</code></pre> <ol> <li>This invocation creates a special kind of test suite for Roboelectric.</li> <li>Test suites and tests inside the Roboelectric environment reside in their own class.</li> <li>We use the usual TestBalloon configuration mechanism.</li> <li>Because the Roboelectric test suite's content resides in its own class, there is no trailing lambda.</li> </ol> <p><code>RenderingTestSuiteContent</code> contains the corresponding test suites and tests, which execute for each combination (6 in total):</p> <pre><code>class RenderingTestSuiteContent : RoboelectricTestSuiteContent({\n    test(\"Send button appears\") {\n        // Android API calls ...\n    }\n\n    testSuite(\"Content\") {\n        test(\"At least three cards display\") {\n            // Android API calls ...\n        }\n\n        // ...\n    }\n})\n</code></pre> <p>Using the above code, we can now verify that</p> <ul> <li>our rendering works as intended on the targeted display formats, and</li> <li>everything involved works across the specified Android API levels.</li> </ul>"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#configuration","title":"Configuration","text":"<p><code>TestConfig.roboelectric</code> lets us configure Roboelectric settings which we would traditionally set via Roboelectric's <code>@Config</code> annotation:</p> <ul> <li>Everything is configured in plain Kotlin.</li> <li>TestBalloon's usual configuration hierarchy applies, which means that settings can be configured at any level of the test element hierarchy, including globally.</li> </ul> <p>The list of settings comprises:</p> Property Type Description <code>sdk</code> <code>Int</code> The Android SDK level to emulate <code>fontScale</code> <code>Float</code> The default font scale <code>application</code> <code>KClass&lt;out Application&gt;</code> The Application class to use in the test <code>qualifiers</code> <code>String</code> Qualifiers specifying device configuration and resource resolution, such as \"fr-normal-port-hdpi\" <code>shadows</code> <code>MutableSet&lt;KClass&lt;*&gt;&gt;</code> A set of shadow classes to enable, in addition to those that are already present <code>instrumentedPackages</code> <code>MutableSet&lt;String&gt;</code> A set of instrumented packages to enable, in addition to those that are already present <code>portableClasses</code> <code>MutableSet&lt;KClass&lt;*&gt;&gt;</code> Classes specified to be portable between Roboelectric and the outside JVM <code>portablePackages</code> <code>MutableSet&lt;String&gt;</code> Packages whose declarations are specified to be portable between Roboelectric and the outside JVM <code>conscryptMode</code> <code>ConscryptMode.Mode</code> The mode of choosing a security provider (can be used to prefer Bouncy Castle over the default Conscrypt) <code>applicationLifetime</code> <code>ApplicationLifetime</code> The lifetime of an application (the default is per test)"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#how-it-works","title":"How it works","text":"<p>Roboelectric runs its tests in a sandboxed Android environment. It does so by loading classes via a special sandbox class loader, modifying their byte code on the way. That means Android test code has to be packaged in special classes, while code outside such classes should remain untouched.</p> <p>Although TestBalloon uses a classless, functional approach throughout, we can reconcile the two paradigms:</p> <ol> <li>We declare subclasses of <code>RoboelectricTestSuiteContent</code>, whose only constructor parameter is a lambda function registering the test suite's content \u2013 just like the trailing lambda of <code>testSuite</code>.</li> <li><code>roboelectricTestSuite</code> then auto-wires the test suite content into TestBalloon's test element hierarchy and feeds the class to Roboelectric. Everything outside and inside that class remains plain Kotlin with the full TestBalloon API, so nested test suites and other features work as usual.</li> </ol>"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#bridging-api-worlds","title":"Bridging API worlds","text":"<p>Roboelectric introduces a new API world with each sandbox it creates. Sandboxes are isolated from each other, which is a welcome side effect. But sandboxes also differ from the outside JVM world. By default, Roboelectric loads all classes it encounters via its sandbox classloader.</p> <p>You might never notice that this happens, but if you're curious, expand the following note to read about possible technical consequences.</p> Note"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#unintended-consequences","title":"Unintended consequences","text":"<p>If we have a regular Kotlin class <code>com.example.MyClass</code>, Roboelectric might reload that class inside a sandbox. Suddenly our inside class has the same name, but a second incarnation under a different identity(1). If this happens, we can enjoy strange errors like this:</p> <ol> <li>The identity of a class consists of its fully qualified name and its classloader.</li> </ol> <p>Failure</p> <pre><code>class com.example.MyClass cannot be cast to class com.example.MyClass (com.example.MyClass is in unnamed module of loader 'app'; com.example.MyClass is in unnamed module of loader org.robolectric.internal.AndroidSandbox$SdkSandboxClassLoader @3bcd426c)\n</code></pre>"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#when-does-this-matter","title":"When does this matter?","text":"<p>In most cases, we don't pass data from the outside world into a Roboelectric test suite. Test suites and tests outside Roboelectric will have their shared parameterization and fixtures, and so will test suites and tests inside a Roboelectric test suite, with very little, if any, overlap.</p> <p>But if the need arises, we can pass data between those worlds. We can declare constructor parameters in our subclass of <code>RoboelectricTestSuiteContent</code> and provide their values via the <code>arguments</code> parameter of <code>roboelectricTestSuite</code>.</p> <p>In these rare cases, we might see the above error. But fortunately, TestBalloon provides an easy way out: We can specify <code>portableClasses</code> or <code>portablePackages</code> in <code>TestConfig.roboelectric</code>. Roboelectric will not touch portable classes, which can then act as conduits between the outside world and Roboelectric sandboxes. Just remember to specify them, so that TestBalloon knows.</p>"},{"location":"blog/2026/02/24/roboelectric-meets-testballoon/#the-best-of-both-worlds","title":"The best of both worlds","text":"<p>With the release of the TestBalloon Roboelectric integration, we no longer have to choose between restrictive, annotation-based APIs or slow and flaky emulator-based test execution. Combining the ease and power of TestBalloon with fast and reliable Roboelectric execution, we can finally have our cake and eat it, too.</p>"},{"location":"getting-started/background/","title":"Background","text":"<p>Testing: the final frontier. These are the voyages of the TestBalloon framework. Its continuing mission: to explore strange new worlds; to seek out new bugs and new integrations; to boldly go where no one has gone before!</p> <p>If you\u2019d like to know why and how TestBalloon came to life, here is some background.</p> <p>You are wondering why TestBalloon works the way it does? Read about its design considerations.</p> <p>Finally, there is a brief introduction to development.</p> <p>For the curious:</p> <ul> <li>Read what needs to be considered when integrating with Kotlin-related build tooling and the IDE.</li> <li>Some details about Android platform support.</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/configuration/#introduction","title":"Introduction","text":"<p>TestBalloon provides two mechanisms to adapt the testing process to your needs via plain Kotlin:</p> <ol> <li> <p><code>TestSuite</code> extensions to register custom tests or test suites.</p> </li> <li> <p><code>TestConfig</code>, a uniform decorator chain API to configure test elements at any level:</p> Single testTest suiteTest compartmentTest session <p></p> <p></p> <p></p> <p></p> </li> </ol> <p>Note</p> <p>TestBalloon aims to be as composable as possible with a simple but powerful API foundation. It is expected that users can more easily achieve their goals with a small amount of their own customization, rather than by using huge APIs and extension libraries.</p>"},{"location":"getting-started/configuration/#testsuite-extensions","title":"<code>TestSuite</code> extensions","text":"<p>To create reusable test variants, you can use extension functions on <code>TestSuite</code>.</p> <ul> <li> <p>A test with a timeout parameter, which also appears in the test's name:</p> <pre><code>fun TestSuiteScope.test(\n    name: String,\n    timeout: Duration,\n    action: suspend Test.ExecutionScope.() -&gt; Unit\n) = test(\n    \"$name (timeout: $timeout)\",\n    testConfig = TestConfig.testScope(false)\n) {\n    try {\n        withTimeout(timeout) {\n            action()\n        }\n    } catch (cancellation: TimeoutCancellationException) {\n        throw AssertionError(\"$cancellation\", cancellation)\n    }\n}\n</code></pre> </li> <li> <p>A reusable test series:</p> <pre><code>fun TestSuiteScope.testSeries(\n    name: String,\n    iterations: Int,\n    action: suspend Test.ExecutionScope.() -&gt; Unit\n) {\n    for (iteration in 1..iterations) {\n        test(\"$name $iteration\") {\n            action()\n        }\n    }\n}\n</code></pre> </li> <li> <p>A test providing a database resource as a context:</p> <pre><code>@TestRegistering // (1)!\nfun TestSuiteScope.databaseTest(\n    name: String,\n    action: suspend Database.() -&gt; Unit\n) {\n    test(name) {\n        Database(this).use { // (2)!\n            it.action() // (3)!\n        }\n    }\n}\n</code></pre> <ol> <li>This annotation makes the IDE plugin aware of the non-standard method signature.</li> <li>Use a standard Kotlin scope function to safely close the resource after use.</li> <li>All test actions can now directly invoke database functions via <code>this</code>.</li> </ol> </li> </ul> <p>Using the same technique, you can create custom test suites, or test suite series.</p>"},{"location":"getting-started/configuration/#testconfig","title":"<code>TestConfig</code>","text":"<p>Use the <code>testConfig</code> parameter in conjunction with the <code>TestConfig</code> decorator chain to configure any part of the test element hierarchy \u2013 your tests, test suites, up to global settings.</p> <pre><code>testSuite(\n    \"let's test concurrency\",\n    testConfig = TestConfig\n        .invocation(TestConfig.Invocation.Concurrent) // (1)!\n        .coroutineContext(MyCoroutineContextElement) // (2)!\n        .statisticsReport() // (3)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>Use concurrent test execution instead of the sequential default.</li> <li>Parallelize as needed (and the platform supports).</li> <li>A custom configuration for extra reporting.</li> </ol>"},{"location":"getting-started/configuration/#custom-combinations","title":"Custom combinations","text":"<p>You can create a custom <code>TestConfig</code> extension combining the above configuration</p> <pre><code>fun TestConfig.onFourThreadsWithStatistics() = this // (1)!\n    .invocation(TestConfig.Invocation.Concurrent)\n    .coroutineContext(MyCoroutineContextElement)\n    .statisticsReport()\n</code></pre> <ol> <li>Starting with <code>this</code> enables <code>TestConfig</code> method chaining: You build on what was present before.</li> </ol> <p>and then reuse it as follows:</p> <pre><code>testSuite(\n    \"let's test concurrency\",\n    testConfig = TestConfig.onFourThreadsWithStatistics()\n) {\n    // ...\n}\n</code></pre>"},{"location":"getting-started/configuration/#custom-extensions","title":"Custom extensions","text":"<p>You can configure a custom <code>TestConfig</code> extension providing a test timeout:</p> <pre><code>fun TestConfig.withTestTimeout(timeout: Duration) = this // (1)!\n    .testScope(isEnabled = false) // (2)!\n    .aroundEachTest { action -&gt; // (3)!\n        try {\n            withTimeout(timeout) {\n                action()\n            }\n        } catch (cancellation: TimeoutCancellationException) {\n            throw AssertionError(\"$cancellation\", cancellation)\n        }\n    }\n</code></pre> <ol> <li>Starting with <code>this</code>, build on what was present before.</li> <li>Enable real time.</li> <li>Wrap around each test <code>action()</code>. By default, you must invoke it at some point, or configure an exception to that rule via <code>TestConfig.addPermits()</code>.</li> </ol> <p>The example in StatisticsReport.kt shows how to create a more complex custom <code>TestConfig</code> extension based on the existing <code>traversal</code> function.</p> <p>You'll be basing a custom extension on one or more existing <code>TestConfig</code> functions. The wrappers are good candidates:</p> <ul> <li><code>TestConfig.aroundAll</code></li> <li><code>TestConfig.aroundEach</code></li> <li><code>TestConfig.aroundEachTest</code></li> </ul> <p>The <code>TestConfig</code> API documentation provides a complete list.</p>"},{"location":"getting-started/configuration/#global-configuration","title":"Global configuration","text":"<p><code>TestSession</code> and <code>TestCompartment</code> are special types of <code>TestSuite</code> that form the top of the test element hierarchy. Like any other <code>TestElement</code>, they can be configured via <code>TestConfig</code>.</p>"},{"location":"getting-started/configuration/#test-compartments","title":"Test compartments","text":"<p>Tests may have different concurrency, isolation and environmental requirements. TestBalloon supports those via <code>TestCompartment</code>s. These group top-level test suites, with each compartment running in isolation.</p> <p>Info</p> <p>If you use compartments C1, C2, C3, TestBalloon will execute all tests in C1, then all tests in C2, then all tests in C3. The order is not determined, but the isolation between all tests in one compartment against tests in the other compartments is guaranteed.</p> <p>TestBalloon has a number of predefined compartments:</p> Predefined compartment Configuration of top-level test suites inside the compartment <code>TestCompartment.Concurrent</code> concurrent/parallel invocation, without <code>TestScope</code> <code>TestCompartment.Default</code> according to <code>TestSession</code>'s default configuration <code>TestCompartment.RealTime</code> sequential invocation, on a real-time dispatcher, without <code>TestScope</code> <code>TestCompartment.Sequential</code> sequential invocation (useful if <code>TestSession</code> is configured differently) <code>TestCompartment.MainDispatcher</code> sequential invocation, with access to a multiplatform <code>Main</code> dispatcher <p>You can use these, or create your own compartments.</p>"},{"location":"getting-started/configuration/#choosing-the-compartment-for-a-test-suite","title":"Choosing the compartment for a test suite","text":"<p>By default, every top-level test suite will be in the <code>TestSession</code>'s default compartment. Use the <code>testSuite</code> function's <code>compartment</code> parameter to put the test suite in a different compartment.</p> <pre><code>val RealTimeTests by testSuite(\n    compartment = { TestCompartment.RealTime } // (1)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol>"},{"location":"getting-started/configuration/#test-session","title":"Test session","text":"<p>The <code>TestSession</code> is a compilation module's root test suite, holding the module-wide default configuration.</p> <p>By default, TestBalloon uses a <code>TestSession</code> with a safe <code>TestSession.DefaultConfiguration</code> for all kinds of tests: It will</p> <ul> <li>execute test elements sequentially</li> <li>on <code>Dispatchers.Default</code>, and</li> <li>use <code>kotlinx.coroutines.test.TestScope</code> inside tests.</li> </ul>"},{"location":"getting-started/configuration/#customization","title":"Customization","text":"<p>You can specify your own test session by declaring a class deriving from <code>TestSession</code> inside the test compilation module it should affect.</p> <p>Tip</p> <p>If you want to reuse a custom test session class from a library, put a class deriving from the library's custom test session class into each of your test modules.</p> <p>To customize a <code>TestSession</code>, change its parameters from their defaults.</p> <p>The <code>testConfig</code> parameter defines the global configuration for the entire compilation module. This example extends the framework\u2019s default configuration:</p> <pre><code>class ModuleTestSession :\n    TestSession(testConfig = DefaultConfiguration.statisticsReport())\n</code></pre> <p>Alternatively, or additionally, you can change the test session's <code>defaultCompartment</code>.</p> <p>If all tests only mutate local state(1) and don't need a <code>TestScope</code>, you can speed up test execution greatly by choosing <code>TestCompartment.Concurrent</code>:</p> <ol> <li>Ascertain that tests do not share mutable state among each other and do not access global mutable state.</li> </ol> <pre><code>class ConcurrentTestSession :\n    TestSession(\n        defaultCompartment = { TestCompartment.Concurrent } // (1)!\n    )\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol>"},{"location":"getting-started/coroutines/","title":"Coroutines","text":""},{"location":"getting-started/coroutines/#structured-testing","title":"Structured testing","text":"<p>TestBalloon arranges test suites and tests in the test element hierarchy.</p> <p></p> <p>A test element hierarchy comprised of test suites and tests. Test compartments and the test session configure the top-level test suites.</p>"},{"location":"getting-started/coroutines/#context-inheritance","title":"Context inheritance","text":"<p>When tests execute, each test element (test, suite, compartment, session) has its own coroutine. The parent-child relationship between these coroutines is the same as between test elements. Coroutine contexts are inherited across the test element hierarchy.</p> <p>Note</p> <p>The coroutine hierarchy mirrors the test element hierarchy.</p>"},{"location":"getting-started/coroutines/#suspending-code","title":"Suspending code","text":"<p>During execution, code can suspend in ( green code of)</p> <ul> <li>tests,</li> <li>test fixtures,</li> <li>execution wrappers.</li> </ul> <p>Info</p> <p>  Blue code inside a test suite (which registers tests, suites, fixtures) cannot suspend. Registration is sequential. This enables consistent multiplatform integration, as lower-level test infrastructures require it.</p>"},{"location":"getting-started/coroutines/#deep-concurrency-and-parallelism","title":"Deep concurrency and parallelism","text":"<p>TestBalloon can be configured to execute tests concurrently or in parallel(1) at any level of the test hierarchy. This means that it can run all tests concurrently, or run selected tests concurrently and others sequentially.</p> <ol> <li>Parallel execution is available on multithreaded platforms whose test infrastructure can handle concurrent test execution. Currently, this applies to the JVM and Native platforms.</li> </ol> <p>Wherever TestBalloon runs tests concurrently, it does so with deep concurrency by default: It uses a common coroutine dispatcher to govern concurrency across the chosen parts of the test element hierarchy. This optimally distributes load across CPU cores.</p> <p>Note</p> <p>Contrast this with shallow concurrency, which parallelizes just the top-level, or complex parallelization schemes configured at different levels. These approaches create concurrency bottlenecks, leave CPUs underutilized, and thus cannot provide comparable throughput.</p> <p>Warning</p> <p>Never use the <code>maxParallelForks</code> option on Gradle test tasks. Gradle has no idea about the test structure and assumes class-based tests, which TestBalloon does not use.</p>"},{"location":"getting-started/coroutines/#testscope-by-default","title":"TestScope by default","text":"<p>All tests use kotlinx.coroutines' TestScope by default, including its virtual time and delay-skipping. A property <code>testScope</code> provides access to this <code>TestScope</code>.</p> <p>Info</p> <p><code>TestConfig.testScope</code> can configure the presence of a <code>TestScope</code> (and its timeout) for all or part of a test element hierarchy. You can always choose to execute your tests on a standard or custom dispatcher, and with real-time behavior.</p> <p>Warning</p> <p><code>TestScope</code> uses <code>runBlocking</code> internally, which is incompatible with concurrent execution on a dispatcher using a limited number of threads. The combination can cause hangups due to thread starvation.</p>"},{"location":"getting-started/examples/","title":"Examples","text":"<p>The TestBalloon repository contains examples covering typical use cases:</p> <ul> <li>TestBalloon\u2019s capabilities in general, including<ul> <li>parameterized (dynamic, data-driven) tests,</li> <li>fixtures (shared context),</li> <li>custom test variants,</li> <li>custom reports,</li> <li>concurrency,</li> <li>other configurations available via <code>TestConfig</code>.</li> </ul> </li> <li>Using TestBalloon for an Android app, containing<ul> <li>host-side tests (a.k.a. unit tests), with and without Roboelectric,</li> <li>device-side tests (a.k.a. instrumented tests),</li> <li>using JUnit 4 rules, and</li> <li>a Jetpack Compose UI test.</li> </ul> </li> <li>Using TestBalloon for a Kotlin Multiplatform plus Android library, containing<ul> <li>host-side tests (a.k.a. unit tests), with and without Roboelectric,</li> <li>device-side tests (a.k.a. instrumented tests).</li> </ul> </li> <li>Using TestBalloon with Kotest assertions.</li> </ul>"},{"location":"getting-started/first-steps/","title":"First steps","text":"<ol> <li> <p>Add the TestBalloon Gradle plugin to your build script:</p> <pre><code>plugins {\n    id(\"de.infix.testBalloon\") version \"$testBalloonVersion\"\n}\n</code></pre> </li> <li> <p>Add a dependency for the TestBalloon framework core library:</p> Kotlin MultiplatformKotlin JVM <pre><code>commonTest {\n    dependencies {\n        implementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n    }\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n}\n</code></pre> <p>Info</p> <p>The repository contains a Multiplatform configuration example.</p> </li> <li> <p>Add extra dependencies for Android (optional):</p> Kotlin Multiplatform with Android host-side testsKotlin Multiplatform with Android device-side testsAndroid-only host-side testsAndroid-only device-side tests <pre><code>named(\"androidHostTest\") { // (1)!\n    dependencies {\n        implementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n        implementation(\"junit:junit:$junit4Version\")\n    }\n}\n</code></pre> <ol> <li>Using the <code>com.android.kotlin.multiplatform.library</code> plugin.</li> </ol> <pre><code>named(\"androidDeviceTest\") { // (1)!\n    dependencies {\n        implementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n        implementation(\"androidx.test:runner:$androidxRunnerVersion\")\n    }\n}\n</code></pre> <ol> <li>Using the <code>com.android.kotlin.multiplatform.library</code> plugin.</li> </ol> <pre><code>dependencies {\n    testImplementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n    testImplementation(\"junit:junit:$junit4Version\")\n}\n</code></pre> <pre><code>dependencies {\n    androidTestImplementation(\"de.infix.testBalloon:testBalloon-framework-core:$testBalloonVersion\")\n    androidTestImplementation(\"androidx.test:runner:$androidxRunnerVersion\")\n}\n</code></pre> <p>Info</p> <p>The repository contains configuration examples for Android and Multiplatform library with Android.</p> </li> <li> <p>Add a dependency for the assertions library of your choice:</p> kotlin.test assertionsKotest assertions <pre><code>implementation(kotlin(\"test\"))\n</code></pre> <pre><code>implementation(\"de.infix.testBalloon:testBalloon-integration-kotest-assertions:$testBalloonVersion\")\n</code></pre> </li> <li> <p>Write a test:</p> <pre><code>val MyFirstTestSuite by testSuite {\n    test(\"string length\") {\n        assertEquals(8, \"Test me!\".length)\n    }\n}\n</code></pre> </li> <li> <p>Run tests via the familiar Gradle test tasks.</p> </li> <li> <p>Install the TestBalloon plugin for IntelliJ IDEA from the JetBrains Marketplace to run individual tests or test suites via the editor\u2019s gutter icons.</p> </li> </ol>"},{"location":"getting-started/fixtures/","title":"Fixtures","text":""},{"location":"getting-started/fixtures/#overview","title":"Overview","text":"<p>A fixture is a state holder for a lazily initialized value, which is to be used in multiple tests.</p> <p>Fixtures come in two flavors:</p> <ul> <li> <p>A test-level fixture provides a fresh value to each single test. The value has a lifetime of that test.</p> </li> <li> <p>A suite-level fixture provides a value which is shared across tests within a test suite. The value is created once on first access. It has a lifetime of the test suite it was registered in.</p> </li> </ul> <p>A fixture is created by the <code>testFixture</code> function, whose trailing lambda produces the fixture's value. It can be an object of an existing class:</p> <pre><code>testFixture {\n    Account(balance = 42.0)\n}\n</code></pre> <p>Alternatively, the value can be a custom object:</p> <pre><code>testFixture {\n    object {\n        val initialBalance = 42.0\n        val account = Account(balance = initialBalance)\n    }\n}\n</code></pre> <p>Note</p> <p>The fixture initialization can suspend. In addition, you can use a suspending <code>closeWith</code> function for tear-down code (see an example in the section on suite-level fixtures below). </p>"},{"location":"getting-started/fixtures/#test-level-fixtures","title":"Test-level fixtures","text":"<p>A fixture becomes a test-level fixture by invoking one of the following functions(1):</p> <ol> <li> <p>The examples use this class declaration:</p> <pre><code>class Account(var balance: Double) {\n    fun add(amount: Double) {\n        balance += amount\n    }\n}\n</code></pre> </li> </ol> <ol> <li> <p><code>asParameterForEach</code> provides a fresh fixture value as a parameter for each test in its scope:</p> <pre><code>testFixture {\n    Account(balance = 42.0)\n} asParameterForEach {\n    test(\"add 10.0\") { account -&gt;\n        account.add(10.0)\n        assertEquals(52.0, account.balance)\n    }\n    test(\"add -10.0\") { account -&gt;\n        account.add(-10.0)\n        assertEquals(32.0, account.balance)\n    }\n}\n</code></pre> </li> <li> <p><code>asContextForEach</code> provides a fresh fixture value as a context (receiver) for each test in its scope:</p> <pre><code>testFixture {\n    Account(balance = 42.0)\n} asContextForEach {\n    test(\"add 11.0\") {\n        add(11.0)\n        assertEquals(53.0, balance)\n    }\n    test(\"add -11.0\") {\n        add(-11.0)\n        assertEquals(31.0, balance)\n    }\n}\n</code></pre> <p>Tip</p> <p>Choose a context along with an <code>object</code> expression to provide multiple properties to tests.</p> </li> </ol> <p>Info</p> <p>Choose a test-level fixture if you want each test to start with the same defined state. This helps to isolate tests from each other. It also makes tests ideal candidates for parallel execution.</p>"},{"location":"getting-started/fixtures/#suite-level-fixtures","title":"Suite-level fixtures","text":"<p>A fixture becomes a suite-level fixture by invoking one of the following functions(1):</p> <ol> <li> <p>The examples use this class declaration:</p> <pre><code>class StarRepository {\n    suspend fun userStars(user: String): Int = 0\n    suspend fun disconnect() {}\n}\n</code></pre> </li> </ol> <ol> <li> <p><code>asParameterForAll</code> provides the same fixture value as a parameter for all tests in its scope:</p> <pre><code>testSuite(\"fixture value as a test parameter\") {\n    val starRepository = testFixture { // (1)!\n        StarRepository() // (2)!\n    } closeWith {\n        disconnect() // (3)!\n    } asParameterForAll {\n        test(\"alina\") { starRepository -&gt;\n            assertEquals(4, starRepository.userStars(\"alina\")) // (4)!\n        }\n        test(\"peter\") { starRepository -&gt;\n            assertEquals(3, starRepository.userStars(\"peter\")) // (5)!\n        }\n    }\n} // (6)!\n</code></pre> <ol> <li>Registers a test fixture with a lifetime of the enclosing test suite.</li> <li>The fixture's setup code can suspend.</li> <li>The fixture's (optional) tear-down code can suspend.</li> <li>The fixture initializes lazily on first use.</li> <li>The second test reuses the same fixture, sharing its setup cost and state.</li> <li>The fixture will close automatically when its suite finishes.</li> </ol> </li> <li> <p><code>asContextForAll</code> provides the same fixture value as a context (receiver) for all tests in its scope:</p> <pre><code>testSuite(\"fixture value as a test context\") {\n    val starRepository = testFixture {\n        StarRepository()\n    } closeWith {\n        disconnect()\n    } asContextForAll {\n        test(\"alina\") {\n            assertEquals(4, userStars(\"alina\"))\n        }\n        test(\"peter\") {\n            assertEquals(3, userStars(\"peter\"))\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p>Choose a context along with an <code>object</code> expression to provide multiple properties to tests.</p> </li> <li> <p>Simply invoking the fixture also provides its value:</p> <pre><code>testSuite(\"fixture value via invoke()\") {\n    val starRepository = testFixture {\n        StarRepository()\n    } closeWith {\n        disconnect()\n    }\n\n    test(\"alina\") {\n        assertEquals(4, starRepository().userStars(\"alina\"))\n    }\n    test(\"peter\") {\n        assertEquals(3, starRepository().userStars(\"peter\"))\n    }\n}\n</code></pre> <p>Tip</p> <p>Invoking the suite-level fixture is practical to provide its value to a test-level fixture. See this example on mixing test-level setup and shared state.</p> </li> </ol> <p>Info</p> <p>Choose a suite-level fixture if you want multiple tests to share state. That way, you can reuse resource-intensive state. Or you can have tests that build upon each other. This is made easy with TestBalloon's default sequential execution, which always runs tests in the order they appear in the source.</p>"},{"location":"getting-started/fixtures/#common-characteristics","title":"Common characteristics","text":"<ul> <li>A fixture can be a suite-level or a test-level fixture, but not both.</li> <li>A fixture's value is always initialized lazily, only when needed.</li> <li>A fixture's initialization and tear-down code can suspend. Inside, you can use code which needs a coroutine scope, or directly create additional coroutines via the <code>testSuiteCoroutineScope</code> property.</li> <li>If a fixture's value is an <code>AutoClosable</code>, the fixture will use its <code>close()</code> method, without requiring <code>closeWith</code>.</li> </ul> <p>Note</p> <p>Ensure that any coroutines created in a fixture finish or get canceled at the end of the fixture's lifetime. The fixture's test or suite will wait for them.</p>"},{"location":"getting-started/integration/","title":"Integration","text":"<p>Note</p> <p>This chapter describes TestBalloon's integration on Kotlin's diverse target platforms. TestBalloon integrations with third-party libraries can be found here.</p> <p>TestBalloon has a unified API for all Kotlin target platforms, residing in the <code>common</code> source set.</p> <p>TestBalloon supports multi-level nesting of test suites and deep concurrency on platforms whose test infrastructure can handle concurrent test execution.</p> <p>Info</p> <p>TestBalloon integrates thoroughly with the platforms' existing APIs and build tooling, using the familiar Gradle tasks and Kotlin's own platform-specific test runtimes.</p> <p>Runtime information and environment variables are available on all platforms via the global <code>testPlatform</code> variable and its <code>TestPlatform</code> interface.</p> <p>The following sections provide an overview about platforms and build tooling. They are not meant to be exhaustive, but highlight selected details.</p>"},{"location":"getting-started/integration/#kotlin-multiplatform","title":"Kotlin Multiplatform","text":""},{"location":"getting-started/integration/#gradle","title":"Gradle","text":"<p>TestBalloon fully integrates with the Kotlin Gradle Plugin (Multiplatform or JVM). It supports</p> <ul> <li>the familiar Gradle and Kotlin test tasks,</li> <li>Gradle-based test filtering,</li> <li>Gradle's test reports (HTML and XML), and</li> <li>the Kotlin Gradle Plugin's combined multiplatform test reports.</li> </ul> <p>TestBalloon can support the incubating Gradle JVM Test Suite Plugin by setting a Gradle property containing the Gradle test suite names as a regular expression, like <code>testBalloon.gradleTestSuiteNamesRegex=integrationTest|anotherGradleSuite</code>.</p> <p>Warning</p> <p>Never use the <code>maxParallelForks</code> option on Gradle test tasks. Gradle has no idea about the test structure and assumes class-based tests, which TestBalloon does not use.</p>"},{"location":"getting-started/integration/#test-selection-filtering","title":"Test selection (filtering)","text":"<p>TestBalloon supports the usual Gradle test task filtering options for all Kotlin Multiplatform targets plus Android host-side (unit) tests.(1)</p> <ol> <li>Android device-side (instrumented) tests do not use Gradle's filtering options since the AGP provides them as verification tasks, not test tasks.</li> </ol> <p>Test selection accepts the pipe <code>|</code> character to separate test elements. This is a valid test invocation:</p> <pre><code>./gradlew cleanJvmTest jvmTest --tests \"com.example.TestSuite|inner suite|*\" --no-build-cache --info\n</code></pre> <p>Alternatively, TestBalloon's own south-east arrow <code>\u2198</code> can be used, or a custom separator if the test patterns begins with one, like <code>;com.example.TestSuite;inner suite;*</code>.</p> <p>Warning</p> <p>IntelliJ IDEA's run configurations can mess with test filtering via <code>--tests</code>. In this case, use the <code>TESTBALLOON_INCLUDE_PATTERNS</code> environment variable instead, like <code>TESTBALLOON_INCLUDE_PATTERNS=com.example.TestSuite|inner suite|*</code>.</p> <p>To use test selection with Android device-side (instrumented) tests, you have these options:</p> <ol> <li> <p>In the IDE's run configuration, use the instrumentation argument <code>TESTBALLOON_INCLUDE_PATTERNS</code> with the pattern as its value.</p> </li> <li> <p>Pass it via Gradle's command line:</p> <pre><code>./gradlew \"-Pandroid.testInstrumentationRunnerArguments.TESTBALLOON_INCLUDE_PATTERNS=com.example.TestSuite|inner suite|*\" ...\n</code></pre> </li> <li> <p>Use the Android Gradle DSL:</p> <pre><code>testInstrumentationRunnerArguments[\"TESTBALLOON_INCLUDE_PATTERNS\"] = \"com.example.TestSuite|inner suite|*\"\n</code></pre> </li> </ol>"},{"location":"getting-started/integration/#jvm","title":"JVM","text":"<p>TestBalloon registers with Gradle, without requiring any platform-specific configuration. TestBalloon can run alongside other JUnit-based test frameworks in the same module.</p> <p>TestBalloon supports deep concurrency and tests running in parallel.</p>"},{"location":"getting-started/integration/#js-wasmjs","title":"JS, Wasm/JS","text":"<p>TestBalloon fully supports the Kotlin Gradle Plugin's test infrastructure, including test execution via Node.js, or in a browser via Karma.</p> <p>TestBalloon supports deep concurrency on JS-based platforms, and provides simulated environment variables in browser tests.</p>"},{"location":"getting-started/integration/#browser-environment-variables","title":"Environment variables","text":"<p>TestBalloon exports only those environment variables into a browser's simulated environment, which are declared browser-safe. To do so, use these options (the build script's setting takes precedence):</p> <ol> <li> <p>Set the Gradle property <code>testBalloon.browserSafeEnvironmentPattern</code> to a regular expression pattern for environment variable names:</p> <pre><code>testBalloon.browserSafeEnvironmentPattern=^(CI|TEST.*)$\n</code></pre> </li> <li> <p>In a build script's <code>testBalloon</code> extension, set the parameter <code>browserSafeEnvironmentPattern</code>:</p> <pre><code>testBalloon {\n    browserSafeEnvironmentPattern = \"^(CI|TEST.*)$\"\n}\n</code></pre> </li> </ol>"},{"location":"getting-started/integration/#native","title":"Native","text":"<p>TestBalloon fully supports the Kotlin Gradle Plugin infrastructure.</p> <p>TestBalloon supports deep concurrency and tests running in parallel.</p>"},{"location":"getting-started/integration/#simulator-environment-variables","title":"Apple simulator environment variables","text":"<p>TestBalloon exports only those environment variables into an Apple simulator's environment, which are declared simulator-safe. To do so, use these options (the build script's setting takes precedence):</p> <ol> <li> <p>Set the Gradle property <code>testBalloon.simulatorSafeEnvironmentPattern</code> to a regular expression pattern for environment variable names:</p> <pre><code>testBalloon.simulatorSafeEnvironmentPattern=^(CI|TEST.*)$\n</code></pre> </li> <li> <p>In a build script's <code>testBalloon</code> extension, set the parameter <code>simulatorSafeEnvironmentPattern</code>:</p> <pre><code>testBalloon {\n    simulatorSafeEnvironmentPattern = \"^(CI|TEST.*)$\"\n}\n</code></pre> </li> </ol>"},{"location":"getting-started/integration/#android","title":"Android","text":"<p>TestBalloon integrates with Android's test infrastructure, the Android Gradle Plugin (AGP), and the Android Gradle Library Plugin for KMP.</p> <p>TestBalloon supports Android's JUnit 4 runner with</p> <ul> <li>Android host-side (unit) tests,</li> <li>device-side (instrumented) tests,</li> <li>JUnit 4 test rules via test fixtures with values of type <code>JUnit4RulesContext</code>,</li> <li>other (non-TestBalloon) JUnit-based tests executing alongside TestBalloon in the same module.</li> </ul> <p>Info</p> <p>In Android host-side tests, two TestBalloon integrations are available: JUnit 4 (preferred) and JUnit Platform. If you enable both (e.g. using JUnit Vintage), TestBalloon will produce an error due to the framework initializing twice. In this case, please disable TestBalloon for JUnit Platform via <code>useJUnitPlatform { excludeEngines(\"de.infix.testBalloon\") }</code>.</p> <p>Note</p> <p>Although Android supports multithreading, TestBalloon will not run tests in parallel on that platform. Android's test infrastructure assumes sequential execution and can cause hangups with tests executing asynchronously.</p>"},{"location":"getting-started/integration/#using-junit-4-test-rules","title":"Using JUnit 4 test rules","text":"<p>The following Jetpack Compose test example demonstrates using JUnit 4 rules in TestBalloon:</p> <pre><code>val JetpackComposeWithTestBalloon by testSuite {\n    testFixture {\n        object : JUnit4RulesContext() { // (1)!\n            val composeTestRule = rule(createComposeRule()) // (2)!\n            val myCustomRule = rule(myCustomRule())\n        }\n    } asContextForEach {\n        test(\"click\") {\n            composeTestRule.setContent {\n                ComposableUnderTest()\n            }\n\n            composeTestRule.onNodeWithText(\"Button\").performClick()\n            composeTestRule.onNodeWithText(\"Success\").assertExists()\n        }\n    }\n}\n</code></pre> <ol> <li>Deriving a fixture value from <code>JUnit4RulesContext</code> enables support for JUnit 4 rules.</li> <li>Instead of annotations, use the <code>rule()</code> function to register a <code>TestRule</code>.</li> </ol>"},{"location":"getting-started/integration/#android-device-environment-variables","title":"Environment variables in device-side (instrumented) tests","text":"<p>For Android device-side tests, TestBalloon provides simulated environment variables via instrumentation arguments. To set them, you have these options:</p> <ol> <li> <p>In the IDE's run configuration, use the instrumentation argument with the variable name and value.</p> </li> <li> <p>Pass it via Gradle's command line:</p> <pre><code>./gradlew \"-Pandroid.testInstrumentationRunnerArguments.VARIABLE_NAME=VALUE\" ...\n</code></pre> </li> <li> <p>Use the Android Gradle DSL:</p> <pre><code>testInstrumentationRunnerArguments[\"VARIABLE_NAME\"] = \"VALUE\"\n</code></pre> </li> </ol>"},{"location":"getting-started/integration/#intellij-idea","title":"IntelliJ IDEA","text":"<p>TestBalloon integrates with IntelliJ IDEA. Some of the functionality is provided by the TestBalloon plugin for IntelliJ IDEA.</p> <ul> <li>Editor windows show run gutter icons to run or debug individual tests or test suites (at any level). Test status indicators (successful, failed) are displayed for JVM targets (except Android tests).</li> <li>Test results appear in IntelliJ's test run window, including the results tree display. The actions \"Run\", \"Debug\", and \"Jump to source\" are available, except for Android device tests.</li> <li>Test elements appear in the file structure tool window and structure popup.</li> <li>Navigating between test elements is possible via the \"Next Method\" and \"Previous Method\" actions.</li> <li>Stack traces in test results hide framework-internal lines by folding.</li> <li>Kotlin inspections allow title-case naming for TestBalloon's top-level suite properties.</li> </ul>"},{"location":"getting-started/integration/#limitations","title":"Limitations","text":"<p>The action \"Rerun Failed Tests\" in the test run window is not supported.</p>"},{"location":"getting-started/tests-and-suites/","title":"Tests and suites","text":""},{"location":"getting-started/tests-and-suites/#overview","title":"Overview","text":"<p>TestBalloon has a DSL-based API with two core functions: <code>testSuite</code> and <code>test</code>.</p> <ul> <li> <p>Tests are functions which either succeed or fail (throw). Tests contain your assertions. Code inside a test can suspend.</p> </li> <li> <p>Test suites structure your tests. They can nest across multiple levels. Code inside a test suite registers tests, test suites, and fixtures.</p> </li> <li> <p>You create top-level test suites as properties with a <code>by testSuite</code> delegation. TestBalloon will find them.</p> </li> </ul> <p>Tests and test suites accept strings as names.</p> <p>Note</p> <p>You have now learned TestBalloon's DSL API. The rest on this page is plain Kotlin.</p> <p>But please familiarize yourself with Green code and blue code and TestBalloon's golden rule.</p> <pre><code>val ExampleTests by testSuite { // (1)!\n    test(\"string length\") { // (2)!\n        assertEquals(8, \"Test me!\".length) // (3)!\n    }\n\n    testSuite(\"integer operations\") { // (4)!\n        test(\"max\") {\n            assertEquals(5, max(5, 3))\n        }\n\n        test(\"min\") {\n            delay(10.milliseconds) // (5)!\n            assertEquals(3, min(5, 3))\n        }\n    }\n}\n</code></pre> <ol> <li>Registers a top-level test suite. TestBalloon will automatically use the property's fully qualified name unless you provide an explicit name.</li> <li>Registers a test.</li> <li>An assertion from <code>kotlin.test</code>.</li> <li>Registers a nested test suite.</li> <li>A suspend function call.</li> </ol>"},{"location":"getting-started/tests-and-suites/#custom-functions-for-tests-and-test-suites","title":"Custom functions for tests and test suites","text":"<p>You can define your own types of tests and test suites, like this test variant with an <code>iterations</code> parameter:</p> <pre><code>fun TestSuiteScope.test( // (1)!\n    name: String,\n    iterations: Int,\n    action: suspend Test.ExecutionScope.() -&gt; Unit\n) = test(name) {\n    for (iteration in 1..iterations) {\n        action()\n    }\n}\n</code></pre> <ol> <li>Using <code>TestSuiteScope</code> as the extension receiver makes your test function universally compatible with all scopes using a test suite, like fixture scopes or custom scopes (e.g. a test series).</li> </ol> <p>Tip</p> <p>While the above code creates a custom test function, you can do the same with a test suite.</p> <p>Find more details under Configuration.</p>"},{"location":"getting-started/tests-and-suites/#parameterized-tests-and-test-suites","title":"Parameterized tests and test suites","text":"<p>In a test suite, you can use all Kotlin constructs (variable scopes, conditions, loops) to create tests and child test suites dynamically.</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre> <p>Parameterization works across test suites:</p> <pre><code>val UserTest by testSuite {\n    for (invalidUserName in listOf(\"\", \"a\", \"+\", \"+foo\")) {\n        testSuite(\"User name '$invalidUserName'\") {\n            for (role in User.Role.entries) {\n                test(\"is invalid with role '$role'\") {\n                    assertFailsWith&lt;IllegalArgumentException&gt; {\n                        User(invalidUserName, role)\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p> </p>"},{"location":"getting-started/tests-and-suites/#using-value-sources-generators","title":"Using value sources (generators)","text":"<p>Value sources help cover test edge cases and/or random samples without repetitive boilerplate code:</p> <pre><code>testSuite(\"Accepted counts\") {\n    val samples = buildList {\n        addAll(listOf(0, 1, Int.MAX_VALUE)) // (1)!\n        val randomSampleSource = Random(42) // (2)!\n        repeat(20) { add(randomSampleSource.nextInt(0, Int.MAX_VALUE)) }\n    }\n\n    for (count in samples) {\n        test(\"count $count is accepted\") {\n            service.updateTransactionCount(count) // should not throw\n        }\n    }\n}\n</code></pre> <ol> <li>Edge cases.</li> <li>Generating repeatable pseudo-random values with a seed.</li> </ol>"},{"location":"getting-started/tests-and-suites/#green-code-and-blue-code","title":"Green code and blue code","text":"<p>Info</p> <p>For a DSL-based framework, it is paramount to be aware of the effects of closures and variable capturing.</p>"},{"location":"getting-started/tests-and-suites/#runtime-phases","title":"Runtime phases","text":"<p>TestBalloon has two primary runtime phases:</p> <p></p> <p>The  test registration phase is part of TestBalloon's setup: It creates the test element hierarchy, registering test suites, tests and fixtures, and configuring test elements. At the end, it knows exactly what to run. (1)</p> <ol> <li>TestBalloon is fast to register tests. It can register and configure 1.7 million tests in 7 seconds on a decent Laptop. It also knows shortcuts if only parts of the test element hierarchy have been selected for execution.</li> </ol> <p>Info</p> <p>The   test registration phase always completes before the  test execution phase starts.</p> <p>The  test execution phase is where the action is. While the default is to run tests sequentially, concurrent execution can be configured at any level of the test element hierarchy.</p>"},{"location":"getting-started/tests-and-suites/#blue-code-registration-phase","title":"Blue code (registration phase)","text":"<p>In TestBalloon, all code outside the lambdas of tests, fixtures and execution wrappers is registration-phase code, or  blue code:</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/tests-and-suites/#green-code-execution-phase","title":"Green code (execution phase)","text":"<p>Code inside the lambdas of tests, fixtures and execution wrappers is execution-phase code, or  green code:</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/tests-and-suites/#testballoons-golden-rule","title":"TestBalloon's golden rule","text":"<p>With power comes some responsibility. The golden rule is:</p> <p>Danger</p> <p>Never leak mutable state from   blue code into  green code.</p> <p>Why is this important?</p>"},{"location":"getting-started/tests-and-suites/#this-breaks","title":"\u274c This breaks","text":"<pre><code>testSuite(\"Broken calculator test suite\") {\n    val calculator = Calculator()\n    val operands = listOf(7, 23, 15)\n    var sum = 0 // (1)\n\n    for (operand in operands) {\n        sum += operand // (2)\n        test(\"add $operand, expect $sum\") {\n            calculator.add(operand)\n            assertEquals(sum, calculator.result) // (3)\n        }\n    }\n}\n</code></pre> <ol> <li><code>sum</code> is mutable state.</li> <li><code>sum</code> is mutated in blue code.</li> <li><code>sum</code> leaks into green code.</li> </ol> <p>The above code will produce failing tests:</p> <p> </p> <p>Why? All the additions to <code>sum</code> occurred in blue code before any green code would start. So green code inside tests can only see the latest blue-code state of <code>sum</code>, which is 45.</p>"},{"location":"getting-started/tests-and-suites/#this-works","title":"\u2705 This works","text":"<pre><code>testSuite(\"Healthy calculator test suite\") {\n    val calculator = Calculator()\n    val operandsAndSums = buildList { // (1)\n        val operands = listOf(7, 23, 15)\n        var sum = 0\n        for (operand in operands) {\n            sum += operand\n            add(operand to sum)\n        }\n    }\n\n    for ((operand, sum) in operandsAndSums) {\n        test(\"add $operand, expect $sum\") {\n            calculator.add(operand) // (2)\n            assertEquals(sum, calculator.result) // (3)\n        }\n    }\n}\n</code></pre> <ol> <li>Blue code contains immutable state only.</li> <li>Well, not entirely: The calculator is mutable. This works, because it is not mutated in blue code, but only in green code.</li> <li>Using immutable state originating in blue code is safe.</li> </ol> <p>Here, all operands and expected <code>sum</code> values were created as immutable state in blue code. This is always safe.</p> <p>Info</p> <p>State leaks with closures, which run later or concurrently, can happen anywhere (flows, sequences, coroutines, anything lazy). For this reason, YouTrack issue KT-15514 suggests to make the compiler emit a warning in such cases.</p>"},{"location":"how-to/effective-testing/","title":"Effective testing","text":"<p>Using TestBalloon's powers, how can we test better with less effort? This section offers guidance for typical scenarios.</p>"},{"location":"how-to/effective-testing/#expressive-names","title":"Expressive names","text":"<p>Make tests communicate their purpose:</p> <pre><code>test(\"User '$user' must be signed in\") {\n    // ...\n}\n</code></pre>"},{"location":"how-to/effective-testing/#write-once-test-many","title":"Write once, test many","text":"<p>Let immutable state describe and drive your test cases:</p> <pre><code>val ParameterizedTests by testSuite {\n    val testCases = mapOf(\n        \"one\" to 3,\n        \"two\" to 3,\n        \"three\" to 5\n    )\n\n    for ((string, expectedLength) in testCases) {\n        test(\"length of '$string' is $expectedLength\") {\n            assertEquals(expectedLength, string.length)\n        }\n    }\n}\n</code></pre>"},{"location":"how-to/effective-testing/#cover-edge-cases-and-samples","title":"Cover edge cases and samples","text":"<p>Test edge cases and/or random samples with value sources (generators):</p> <pre><code>testSuite(\"Accepted counts\") {\n    val samples = buildList {\n        addAll(listOf(0, 1, Int.MAX_VALUE)) // (1)!\n        val randomSampleSource = Random(42) // (2)!\n        repeat(20) { add(randomSampleSource.nextInt(0, Int.MAX_VALUE)) }\n    }\n\n    for (count in samples) {\n        test(\"count $count is accepted\") {\n            service.updateTransactionCount(count) // should not throw\n        }\n    }\n}\n</code></pre> <ol> <li>Edge cases.</li> <li>Generating repeatable pseudo-random values with a seed.</li> </ol> <p>One test per sample documents which tests were actually run:</p> <p> </p>"},{"location":"how-to/effective-testing/#supply-fresh-state-to-multiple-tests","title":"Supply fresh state to multiple tests","text":"<p>To conveniently provide each test with fresh state, available as a context via <code>this</code>, use a fixture and provide its value as a context for each test:</p> <pre><code>testSuite(\"Multiple tests with fresh state\") {\n    testFixture {\n        Service().apply {\n            signIn(userName = \"siobhan\", password = \"ask\") // (1)!\n        } // (2)!\n    } closeWith {\n        signOut() // (3)!\n    } asParameterForEach {\n        test(\"deposit\") { service -&gt;\n            service.deposit(Amount(20.0))\n            assertEquals(Amount(40.99), service.accountBalance())\n        }\n\n        test(\"withdraw\") { service -&gt;\n            service.withdraw(Amount(20.0))\n            assertEquals(Amount(0.99), service.accountBalance())\n        }\n    }\n}\n</code></pre> <ol> <li><code>signIn</code> can be a suspending function.</li> <li>If you want to provide multiple values, use an <code>object</code>  expression inside the fixture and <code>asContextForEach</code>.</li> <li><code>signOut</code> may also suspend.</li> </ol> <p>Tip</p> <p>In this case, tests are fully isolated from each other, and don't need a <code>TestScope</code>. They are ideal candidates for concurrent execution.</p>"},{"location":"how-to/effective-testing/#use-shared-state-across-multiple-tests","title":"Use shared state across multiple tests","text":"<p>To conveniently share state among tests, use a fixture's value as a shared context for all tests:</p> <pre><code>testSuite(\"Multiple tests sharing state\") {\n    testFixture {\n        object {\n            val service = Service().apply {\n                signIn(userName = \"siobhan\", password = \"ask\")\n            }\n            var expectedCount = 0 // (1)!\n        }\n    } closeWith {\n        service.signOut()\n    } asContextForAll {\n        test(\"deposit\") {\n            service.deposit(Amount(20.0))\n            assertEquals(Amount(40.99), service.accountBalance())\n            assertEquals(++expectedCount, service.transactionCount())\n        }\n\n        test(\"withdraw\") {\n            service.withdraw(Amount(20.0))\n            assertEquals(Amount(20.99), service.accountBalance())\n            assertEquals(++expectedCount, service.transactionCount())\n        }\n    }\n}\n</code></pre> <ol> <li>We can use mutable state here. This is green code which exists exclusively at test execution time, preserving TestBalloon's golden rule.</li> </ol> <p>Tip</p> <p>Writing tests that build on each other is easy, because, by default, TestBalloon runs tests in the order they appear in the source. Just make sure that you don't configure concurrent execution for them.</p>"},{"location":"how-to/effective-testing/#make-tests-run-fast","title":"Make tests run fast","text":""},{"location":"how-to/effective-testing/#if-all-tests-avoid-non-local-mutable-state","title":"\u2026if all tests avoid non-local mutable state","text":"<p>If you have a module where all tests only mutate local state(1) and don't need a <code>TestScope</code>, you can speed up test execution greatly by running them concurrently. To do so, put this declaration anywhere in your test module:</p> <ol> <li>Ascertain that tests do not share mutable state among each other and do not access global mutable state.</li> </ol> <pre><code>class ConcurrentTestSession :\n    TestSession(\n        defaultCompartment = { TestCompartment.Concurrent } // (1)!\n    )\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol>"},{"location":"how-to/effective-testing/#if-most-tests-avoid-non-local-mutable-state","title":"\u2026if most tests avoid non-local mutable state","text":"<ol> <li> <p>Configure the module's test session for concurrency:</p> <pre><code>class ConcurrentTestSession :\n    TestSession(\n        defaultCompartment = { TestCompartment.Concurrent } // (1)!\n    )\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol> </li> <li> <p>Put top-level test suites, whose test's access non-local mutable state or need a <code>TestScope</code>, in the predefined <code>Sequential</code> compartment:</p> <pre><code>val TestsSharingMutableState by testSuite(\n    compartment = { TestCompartment.Sequential } // (1)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol> </li> </ol> <p>TestBalloon will now execute tests in the <code>Sequential</code> compartment sequentially, and also isolate them from all concurrent tests.</p>"},{"location":"how-to/effective-testing/#if-only-some-tests-can-run-concurrently","title":"\u2026if only some tests can run concurrently","text":"<p>Put top-level test suites, whose test's can run concurrently and don't need a <code>TestScope</code>, in the predefined <code>Concurrent</code> compartment:</p> <pre><code>val ConcurrentTests by testSuite(\n    compartment = { TestCompartment.Concurrent } // (1)!\n) {\n    // ...\n}\n</code></pre> <ol> <li>For technical reasons, a compartment assignment must be done lazily.</li> </ol> <p>TestBalloon will now execute most tests sequentially (by default), and isolate them from those in the <code>Concurrent</code> compartment, where they run concurrently.</p>"},{"location":"how-to/effective-testing/#a-ui-test-with-jetpack-compose","title":"A UI test with Jetpack Compose","text":"<p>TestBalloon does not bundle Compose dependencies, but it does provide a <code>JUnit4RulesContext</code> to create test-level fixtures supporting JUnit 4 rules.</p> <p>With it, you can use Jetpack Compose tests inside TestBalloon via <code>composeTestRule</code>, as shown in the Google documentation:</p> <pre><code>val JetpackComposeWithTestBalloon by testSuite {\n    testFixture {\n        object : JUnit4RulesContext() { // (1)!\n            val composeTestRule = rule(createComposeRule()) // (2)!\n            val myCustomRule = rule(myCustomRule())\n        }\n    } asContextForEach {\n        test(\"click\") {\n            composeTestRule.setContent {\n                ComposableUnderTest()\n            }\n\n            composeTestRule.onNodeWithText(\"Button\").performClick()\n            composeTestRule.onNodeWithText(\"Success\").assertExists()\n        }\n    }\n}\n</code></pre> <ol> <li>Deriving a fixture value from <code>JUnit4RulesContext</code> enables support for JUnit 4 rules.</li> <li>Instead of annotations, use the <code>rule()</code> function to register a <code>TestRule</code>.</li> </ol> <p>See complete code in this Jetpack Compose test example.</p>"},{"location":"how-to/effective-testing/#a-ui-test-with-compose-multiplatform","title":"A UI test with Compose Multiplatform","text":"<p>Compose Multiplatform provides an experimental <code>runComposeUiTest()</code> API. To use it with TestBalloon, create a custom DSL function like this:(1)</p> <ol> <li>Using the Compose Multiplatform test API requires an opt-in directive like <code>@file:OptIn(ExperimentalTestApi::class)</code>.</li> </ol> <pre><code>@TestRegistering\nfun TestSuiteScope.composeTest(name: String, action: suspend ComposeUiTest.() -&gt; Unit) = test(name) {\n    @OptIn(TestBalloonExperimentalApi::class) // required for TestBalloon's testTimeout\n    runComposeUiTest(\n        runTestContext = coroutineContext.minusKey(CoroutineExceptionHandler.Key),\n        testTimeout = testTimeout ?: 60.seconds\n    ) {\n        action()\n    }\n}\n</code></pre> <p>With that, you can use Compose Multiplatform tests inside TestBalloon as shown in the JetBrains documentation.(1)</p> <ol> <li>Using the Compose Multiplatform test API requires an opt-in directive like <code>@file:OptIn(ExperimentalTestApi::class)</code>.</li> </ol> <pre><code>val ComposeMultiplatformTests by testSuite {\n    composeTest(\"click\") {\n        setContent {\n            ComposableUnderTest()\n        }\n\n        onNodeWithText(\"Button\").performClick()\n        onNodeWithText(\"Success\").assertExists()\n    }\n}\n</code></pre>"},{"location":"how-to/effective-testing/#handling-flaky-tests","title":"Handling flaky tests","text":"<p>One way of handling flaky tests is to repeat them until they succeed.</p> <p>Create a <code>TestConfig</code> extension:</p> <pre><code>fun TestConfig.repeatOnFailure(maxRepetitions: Int) = aroundEachTest { action -&gt;\n    var lastException: Throwable? = null\n    repeat(maxRepetitions) {\n        try {\n            action()\n            return@aroundEachTest\n        } catch (exception: Throwable) {\n            lastException = exception\n            // suppress as long as we try repeatedly\n        }\n    }\n    throw lastException!!\n}\n</code></pre> <p>Use it like this:</p> <pre><code>val FlakyTests by testSuite {\n    testSuite(\"not controlled\") {\n        test(\"would succeed after 3 failures\") {\n            doSomethingFlaky()\n        }\n    }\n\n    testSuite(\"under control\", testConfig = TestConfig.repeatOnFailure(5)) {\n        test(\"succeeds after 3 failures\") {\n            doSomethingFlaky()\n        }\n\n        test(\"always fails\") {\n            throw Error(\"always failing\")\n        }\n    }\n}\n</code></pre> <p>The outcome:</p> <p> </p>"},{"location":"how-to/effective-testing/#conditional-tag-based-testing","title":"Conditional tag-based testing","text":"<p>TestBalloon provides the option of using environment variables to control test execution on all Kotlin targets.(1)</p> <ol> <li>JS browsers and Android (emulated or physical) devices do not natively support environment variables. TestBalloon provides a (simulated) environment for those. For Android device-side tests, you need to set them via instrumentation arguments. For JS browsers, you need to declare them as browser-safe.</li> </ol> <p>If you define tags(1) and a <code>TestConfig</code> extension like this,</p> <ol> <li>These are your tags, literally, in plain Kotlin, instead of some complex pre-defined tag regime.</li> </ol> <pre><code>enum class MyTag {\n    CI,\n    SimulatedCI,\n    Release;\n\n    fun value() =\n        testPlatform.environment(\"TEST_TAGS\")?.split(',')?.last { it == name }\n\n    fun exists() = value() != null\n}\n\nfun TestConfig.onlyIfTagged(vararg tags: MyTag) =\n    if (tags.any { it.exists() }) this else disable()\n</code></pre> <p>\u2026you can use a <code>TEST_TAGS</code> environment variable to conditionally run tests and suites at any level of the test element hierarchy:</p> <pre><code>val ConditionalTests by testSuite(\n    testConfig = TestConfig.onlyIfTagged(MyTag.CI, MyTag.SimulatedCI)\n) {\n    // ...\n}\n</code></pre>"},{"location":"how-to/effective-testing/#use-a-temporary-directory-and-keep-it-on-failures","title":"Use a temporary directory (and keep it on failures)","text":"<p>Some tests require a temporary directory. Let's suppose you want to keep it for inspection if there were test failures \u2013 but not on CI. Let's also require the directory name to identify the test by default.</p> <p>Create a test fixture for the directory, deleting it at the end of its lifecycle (its test or test suite):</p> <pre><code>fun TestSuiteScope.temporaryDirectoryFixture(\n    prefix: String = \"${testSuiteInScope.testElementPath}-\" // (1)!\n) = testFixture {\n    Files.createTempDirectory(Path(\"build/tmp\"), prefix) // (2)!\n} closeWith { testsSucceeded -&gt;\n    if (testsSucceeded || testPlatform.environment(\"CI\") != null) {\n        deleteRecursively()\n    } else {\n        println(\"Temporary directory: file://${toAbsolutePath()}\") // (3)!\n    }\n}\n</code></pre> <ol> <li>Prefixes the directory with a name identifying the test suite.</li> <li>The directory (a <code>Path</code>) is the fixture's value.</li> <li>Show the path on failures for easy inspection. </li> </ol> <p>If you need a directory per test, use it like this:</p> <pre><code>testSuite(\"temporary directory per test\") {\n    temporaryDirectoryFixture().asParameterForEach {\n        test(\"one\") { directory -&gt;\n            (directory / \"my-result1.txt\").writeText(\"one\")\n        }\n\n        test(\"two\") { directory -&gt;\n            (directory / \"my-result2.txt\").writeText(\"two\")\n        }\n    }\n}\n</code></pre> <p>If you need a directory per test suite, use it like this:(1)</p> <ol> <li>You can also use the others variants like <code>asParameterForAll</code>.</li> </ol> <pre><code>testSuite(\"temporary directory per suite (invokable val)\") {\n    val directory = temporaryDirectoryFixture()\n\n    test(\"one\") {\n        (directory() / \"my-result1.txt\").writeText(\"one\")\n    }\n\n    test(\"two\") {\n        (directory() / \"my-result2.txt\").writeText(\"two\")\n    }\n}\n</code></pre>"},{"location":"how-to/migrating-from-junit/","title":"\u2026from JUnit","text":""},{"location":"how-to/migrating-from-junit/#choose-your-pace","title":"Choose your pace","text":"<p>TestBalloon can reside with JUnit 4/5/6 tests in the same module(1), running tests side-by-side.</p> <ol> <li>For Android host-side tests: If you have JUnit Platform and JUnit 4 enabled (e.g. by using JUnit Vintage), please disable TestBalloon on JUnit Platform via <code>useJUnitPlatform { excludeEngines(\"de.infix.testBalloon\") }</code>. Otherwise, the framework would respond to both integrations and initialize twice, which produces an error.</li> </ol> <p>You can migrate at your pace, and you don't need to migrate code that does not benefit from TestBalloon's capabilities.</p>"},{"location":"how-to/migrating-from-junit/#keep-your-assertions","title":"Keep your assertions","text":"<p>You can keep your assertion library (most assertion libraries work out of the box, for Kotest Assertions there is a TestBalloon integration for it). Code inside tests can remain unchanged.</p>"},{"location":"how-to/migrating-from-junit/#what-needs-to-change","title":"What needs to change","text":""},{"location":"how-to/migrating-from-junit/#test-classes-and-methods","title":"Test Classes and Methods","text":"<p>Top-level test classes become top-level suite properties. Test methods become <code>test</code> function invocations:</p> JUnitTestBalloon <pre><code>class JUnitBasics {\n    @Test\n    fun expected_to_pass() {\n        Assert.assertEquals(4, 2 + 2)\n    }\n\n    @Test\n    fun expected_to_fail() {\n        Assert.assertEquals(5, 2 + 2)\n    }\n}\n</code></pre> <pre><code>val FromJUnitBasics by testSuite {\n    test(\"expected to pass\") {\n        Assert.assertEquals(4, 2 + 2)\n    }\n\n    test(\"expected to fail\") {\n        Assert.assertEquals(5, 2 + 2)\n    }\n}\n</code></pre>"},{"location":"how-to/migrating-from-junit/#class-properties-setup-and-teardown","title":"Class properties, setup and teardown","text":"<p>Keep your code inside tests, and</p> <ol> <li>wrap JUnit class properties into a fixture, omitting <code>var</code> and <code>lateinit</code>,</li> <li>omit <code>runTest</code>,</li> <li>co-locate setup code with initialization,</li> <li>use the optional <code>closeWith</code> lambda for tear-down code,</li> <li>make it a test-level fixture, providing a fresh value to each test:</li> </ol> JUnitTestBalloon <pre><code>class JUnitTestLevelFixture {\n    private lateinit var service: WeatherService\n\n    @Before // (1)!\n    fun setup() = runTest {\n        service = FakeWeatherService()\n        service.connect(token = \"TestToken\")\n    }\n\n    @After // (2)!\n    fun teardown() = runTest {\n        service.disconnect()\n    }\n\n    @Test\n    fun `Temperature in Hamburg is 21_5 \u00b0C`() = runTest {\n        Assert.assertEquals(21.5, service.location(\"Hamburg\").temperature)\n    }\n\n    // more tests...\n}\n</code></pre> <ol> <li><code>@BeforeEach</code> in JUnit 5+.</li> <li><code>@AfterEach</code> in JUnit 5+.</li> </ol> <pre><code>val FromJUnitTestLevelFixture by testSuite {\n    testFixture {\n        FakeWeatherService().apply {\n            connect(token = \"TestToken\") // (1)!\n        }\n    } closeWith {\n        disconnect() // (2)!\n    } asParameterForEach { // (3)!\n\n        test(\"Temperature in Hamburg is 21.5 \u00b0C\") { service -&gt;\n            Assert.assertEquals(21.5, service.location(\"Hamburg\").temperature)\n        }\n\n        // more tests...\n    }\n}\n</code></pre> <ol> <li>As the <code>testFixture</code> lambda is suspending, you can co-locate any setup code here.</li> <li>A suspending tear-down function.</li> <li>Making it a test-level fixture provides a fresh, isolated value as a parameter for each test.</li> </ol> <p>Tip</p> <p>For a fixture with multiple properties, use an <code>object</code> expression and provide it via <code>asContextForEach</code> to each test.</p>"},{"location":"how-to/migrating-from-junit/#sharing-state-across-tests","title":"Sharing state across tests","text":"<p>Keep your code inside tests, and</p> <ol> <li>wrap JUnit class properties into a fixture, omitting <code>var</code>, <code>lateinit</code>, and static declarations (companion object),</li> <li>co-locate setup code with initialization,</li> <li>use the optional <code>closeWith</code> lambda for tear-down code,</li> <li>make it a suite-level fixture, providing a shared value to all tests:</li> </ol> JUnitTestBalloon <pre><code>class JUnitClassLevelFixture {\n    companion object {\n        private lateinit var service: WeatherService\n\n        @JvmStatic\n        @BeforeClass // (1)!\n        fun setup(): Unit = runTest {\n            service = FakeWeatherService()\n            service.connect(token = \"TestToken\")\n        }\n\n        @JvmStatic\n        @AfterClass // (2)!\n        fun teardown() = runTest {\n            service.disconnect()\n        }\n    }\n\n    @Test\n    fun `Temperature in Hamburg is 21_5 \u00b0C`() = runTest {\n        Assert.assertEquals(\n            21.5,\n            service.location(\"Hamburg\").temperature\n        )\n    }\n\n    // more tests...\n}\n</code></pre> <ol> <li><code>@BeforeAll</code> in JUnit 5+.</li> <li><code>@AfterAll</code> in JUnit 5+.</li> </ol> <pre><code>val FromJUnitClassLevelFixture by testSuite {\n    testFixture {\n        FakeWeatherService().apply {\n            connect(token = \"TestToken\")\n        }\n    } closeWith {\n        disconnect()\n    } asParameterForAll { // (1)!\n\n        test(\"Temperature in Hamburg is 21.5 \u00b0C\") { service -&gt;\n            Assert.assertEquals(21.5, service.location(\"Hamburg\").temperature)\n        }\n\n        // more tests...\n    }\n}\n</code></pre> <ol> <li>Making it a suite-level fixture provides a shared value as a parameter for all tests.</li> </ol> <p>Tip</p> <p>For a fixture with multiple properties, use an <code>object</code> expression and provide it as via <code>asContextForAll</code> to all tests.</p>"},{"location":"how-to/migrating-from-junit/#mixing-test-level-setup-and-shared-state","title":"Mixing test-level setup and shared state","text":"<p>Use the test-level fixture as shown above, and use additional shared fixtures for class-level state:</p> JUnitTestBalloon <pre><code>class JUnitMixedFixture {\n    companion object {\n        private lateinit var service: WeatherService\n\n        @JvmStatic\n        @BeforeClass // (1)!\n        fun setup(): Unit = runTest {\n            service = FakeWeatherService()\n        }\n    }\n\n    @Before // (2)!\n    fun setup() = runTest {\n        service.connect(token = \"TestToken\")\n    }\n\n    @After // (3)!\n    fun teardown() = runTest {\n        service.disconnect()\n    }\n\n    @Test\n    fun `Temperature in Hamburg is 21_5 \u00b0C`() = runTest {\n        Assert.assertEquals(21.5, service.location(\"Hamburg\").temperature)\n    }\n\n    // more tests...\n}\n</code></pre> <ol> <li><code>@BeforeAll</code> in JUnit 5+.</li> <li><code>@BeforeEach</code> in JUnit 5+.</li> <li><code>@AfterEach</code> in JUnit 5+.</li> </ol> <pre><code>val FromJUnitMixedFixture by testSuite {\n    val sharedService = testFixture { FakeWeatherService() }\n\n    testFixture {\n        sharedService().apply { // (1)!\n            connect(token = \"TestToken\")\n        }\n    } closeWith {\n        disconnect()\n    } asParameterForEach {\n\n        test(\"Temperature in Hamburg is 21.5 \u00b0C\") { service -&gt;\n            Assert.assertEquals(21.5, service.location(\"Hamburg\").temperature)\n        }\n\n        // more tests...\n    }\n}\n</code></pre> <ol> <li>Invoking the <code>sharedService</code> fixture makes it a suite-level fixture.</li> </ol>"},{"location":"how-to/migrating-from-junit/#junit-4","title":"JUnit 4","text":""},{"location":"how-to/migrating-from-junit/#rules","title":"Rules","text":"<ol> <li>Use a fixture as shown before, but put properties into an object deriving from a <code>JUnit4RulesContext</code>.</li> <li>Instead of <code>@Rule</code> annotations, register rules via a <code>rule()</code> function.</li> </ol> JUnitTestBalloon <pre><code>class JetpackComposeWithJUnit4 {\n    @get:Rule\n    val composeTestRule = createComposeRule()\n\n    @get:Rule\n    val myCustomRule = myCustomRule()\n\n    @Test\n    fun click() {\n        composeTestRule.setContent {\n            ComposableUnderTest()\n        }\n\n        composeTestRule.onNodeWithText(\"Button\").performClick()\n        composeTestRule.onNodeWithText(\"Success\").assertExists()\n    }\n}\n</code></pre> <pre><code>val JetpackComposeWithTestBalloon by testSuite {\n    testFixture {\n        object : JUnit4RulesContext() { // (1)!\n            val composeTestRule = rule(createComposeRule()) // (2)!\n            val myCustomRule = rule(myCustomRule())\n        }\n    } asContextForEach {\n        test(\"click\") {\n            composeTestRule.setContent {\n                ComposableUnderTest()\n            }\n\n            composeTestRule.onNodeWithText(\"Button\").performClick()\n            composeTestRule.onNodeWithText(\"Success\").assertExists()\n        }\n    }\n}\n</code></pre> <ol> <li>Deriving a fixture value from <code>JUnit4RulesContext</code> enables support for JUnit 4 rules.</li> <li>Instead of annotations, use the <code>rule()</code> function to register a <code>TestRule</code>.</li> </ol> <p>Tip</p> <p>Use only pre-existing rules with TestBalloon, avoid creating new ones. Rules are blocking by nature and do not mesh well with Kotlin's coroutines. Use TestBalloon's <code>TestConfig.aroundEachTest()</code> to wrap code around tests with full coroutine support.</p>"},{"location":"how-to/migrating-from-junit/#parameterized-tests","title":"Parameterized tests","text":"<ol> <li>Drop <code>@RunWith(Parameterized::class)</code>, class properties for parameters, and the companion object.</li> <li>Use plain Kotlin:</li> </ol> JUnitTestBalloon <pre><code>@RunWith(Parameterized::class)\nclass JUnit4Parameterized(val city: String, val expectedTemperature: Double) {\n    companion object {\n        @JvmStatic\n        @Parameterized.Parameters(name = \"{0} {1}\")\n        fun data() =\n            mapOf(\"Hamburg\" to 21.5, \"Munich\" to 25.0, \"Berlin\" to 23.5)\n                .map { (city, expectedTemperature) -&gt;\n                    arrayOf&lt;Any&gt;(city, expectedTemperature)\n                }\n    }\n\n    private lateinit var service: WeatherService\n\n    @Before\n    fun setup() = runTest {\n        service = FakeWeatherService()\n        service.connect(token = \"TestToken\")\n    }\n\n    @After\n    fun teardown() = runTest {\n        service.disconnect()\n    }\n\n    @Test\n    fun `Location has expected temperature`() = runTest {\n        Assert.assertEquals(\n            expectedTemperature,\n            service.location(city).temperature\n        )\n    }\n}\n</code></pre> <pre><code>val FromJUnit4Parameterized by testSuite {\n    testFixture {\n        FakeWeatherService().apply {\n            connect(token = \"TestToken\")\n        }\n    } closeWith {\n        disconnect()\n    } asParameterForEach {\n        mapOf(\n            \"Hamburg\" to 21.5,\n            \"Munich\" to 25.0,\n            \"Berlin\" to 23.5\n        ).forEach { (city, expectedTemperature) -&gt;\n            test(\n                \"Temperature in $city is $expectedTemperature \u00b0C\"\n            ) { service -&gt;\n                Assert.assertEquals(\n                    expectedTemperature,\n                    service.location(city).temperature\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"how-to/migrating-from-junit/#junit-5-junit-6","title":"JUnit 5, JUnit 6","text":""},{"location":"how-to/migrating-from-junit/#parameterization","title":"Parameterization","text":"<p>JUnit 5+ offers parameterization via <code>@ParameterizedClass</code> and <code>@MethodSource</code> annotations. These are very similar to JUnit 4 parameterized tests. The same migration techniques apply.</p> <p>Migrating JUnit 5+ templated tests to TestBalloon follows the same pattern.</p>"},{"location":"how-to/migrating-from-junit/#ordering","title":"Ordering","text":"<p>To run tests in a chosen order, JUnit 5+ requires interventions (like an <code>@Order</code> annotation). In TestBalloon, tests run in the order they appear in the source by default.</p>"},{"location":"how-to/migrating-from-junit/#extensions","title":"Extensions","text":"<p>JUnit 5+ extensions are reusable classes whose methods can run code before, after, or around tests.</p> <p>TestBalloon's TestConfig decorator chain provides 4 functional mechanisms which achieve the same:</p> <ul> <li>two universal functions: <code>aroundEach()</code> and <code>traversal()</code>,</li> <li>two convenience variants: <code>aroundAll()</code> and <code>aroundEachTest()</code>.</li> </ul> JUnitTestBalloon <pre><code>@ExtendWith(TimingExtension::class)\nclass JUnit6WithExtension {\n    @Test\n    fun `some test`() {\n        // Code to be timed\n    }\n}\n\nclass TimingExtension : InvocationInterceptor {\n    override fun interceptTestMethod(\n        invocation: InvocationInterceptor.Invocation&lt;Void?&gt;,\n        invocationContext: ReflectiveInvocationContext&lt;Method&gt;,\n        extensionContext: ExtensionContext\n    ) {\n        val duration = measureTime {\n            super.interceptTestMethod(\n                invocation,\n                invocationContext,\n                extensionContext\n            )\n        }\n        println(\n            \"TIME: ${extensionContext.requiredTestMethod.name} took $duration.\"\n        )\n    }\n}\n</code></pre> <pre><code>val FromJUnit6WithExtension by testSuite(testConfig = TestConfig.timed()) {\n    test(\"some test\") {\n        // Code to be timed\n    }\n}\n\nfun TestConfig.timed() = aroundEachTest { action -&gt;\n    val duration = measureTime {\n        action()\n    }\n    println(\"TIME: $testElementPath took $duration.\")\n}\n</code></pre>"},{"location":"how-to/migrating-from-junit/#other","title":"Other","text":"<p>Nested and dynamic tests are covered as TestBalloon's <code>testSuite</code> functions nest and everything is dynamic by nature.</p> <p>Most other JUnit 5+ features like disabling tests, conditional execution, tagging, repeated tests have a natural replacement using plain Kotlin, TestBalloon's TestConfig decorator chain, and environment variables (see this example).</p>"},{"location":"how-to/migrating-from-kotest/","title":"\u2026from Kotest","text":""},{"location":"how-to/migrating-from-kotest/#keep-your-structure-and-assertions","title":"Keep your structure and assertions","text":"<p>Like Kotest, TestBalloon is DSL-based and offers a choice of assertion libraries:</p> <ul> <li> <p>You can possibly keep large parts of your test structure by using some helper functions which translate from one of Kotest's test styles to TestBalloon's <code>testSuite</code> and <code>test</code> DSL functions.</p> <p>Tip</p> <p>TestBalloon Addons by A-SIT Plus is a ready-to-use library which provides a translation for <code>FreeSpec</code>, plus replacements for Kotest's data-driven and property test functions.</p> </li> <li> <p>You can keep your assertion library (if it is Kotest Assertions, TestBalloon has an integration for it).</p> </li> </ul>"},{"location":"how-to/migrating-from-kotest/#what-needs-to-change","title":"What needs to change","text":""},{"location":"how-to/migrating-from-kotest/#specs","title":"Specs","text":"<p>Kotest's specs become TestBalloon's top-level test suites:</p> KotestTestBalloon <pre><code>class MyTests : FunSpec({\n    test(\"String length should return the length of the string\") {\n        \"sammy\".length shouldBe 5\n        \"\".length shouldBe 0\n    }\n})\n</code></pre> <pre><code>val MyTests by testSuite {\n    test(\"String length should return the length of the string\") {\n        \"sammy\".length shouldBe 5\n        \"\".length shouldBe 0\n    }\n}\n</code></pre>"},{"location":"how-to/migrating-from-kotest/#isolation-modes","title":"Isolation Modes","text":"<p>You can keep all code in Kotest's default Single Instance mode.</p> <p>For Kotest's <code>InstancePerRoot</code> and <code>InstancePerLeaf</code> isolation modes, keep tests as they are, but wrap them into a test-level fixture:</p> KotestTestBalloon <pre><code>class IsolatedTests : FunSpec({\n    isolationMode = IsolationMode.InstancePerLeaf // (1)!\n\n    val id = UUID.randomUUID() // (2)!\n\n    init {\n        test(\"one\") {\n            println(id) // (3)!\n        }\n        test(\"two\") {\n            println(id) // (4)!\n        }\n    }\n})\n</code></pre> <ol> <li>Kotest 6 deprecates <code>InstancePerLeaf</code> in favor of <code>InstancePerRoot</code>, but the latter isolates only one level of tests.</li> <li>The test context is initialized by re-creating the spec from its class via reflection (JVM-only).</li> <li>Each test prints a different ID.</li> <li>Each test prints a different ID.</li> </ol> <pre><code>val IsolatedTests by testSuite {\n    testFixture {\n        Uuid.random() // (1)!\n    } asParameterForEach { // (2)!\n        test(\"one\") { uuid -&gt;\n            println(uuid) // (3)!\n        }\n        test(\"two\") { uuid -&gt;\n            println(uuid) // (4)!\n        }\n    }\n}\n</code></pre> <ol> <li>The fixture's value can be any Kotlin type. You can also use an object expression with multiple properties.</li> <li>This test-level fixture provides a fresh, isolated parameter for each test.</li> <li>Each test prints a different ID.</li> <li>Each test prints a different ID.</li> </ol> <p>Note</p> <p>When migrating existing code, please remember the concepts of Green code and blue code and TestBalloon's golden rule.</p> <p>Tip</p> <p>Sharing state via TestBalloon's suite-level fixtures may help you squeeze complexity out of existing code, which did not have access to this mechanism.</p>"},{"location":"how-to/migrating-from-kotest/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Replace Kotest's lifecycle hooks with TestBalloon's wrappers, like in this re-use example:</p> KotestTestBalloon <pre><code>val printStart: BeforeTest = {\n    println(\"Starting a test $it\")\n}\n\nclass LifecycleHookTests : FunSpec({\n    beforeTest(printStart)\n    test(\"this test should be alive\") {\n        println(\"Johnny5 is alive!\")\n    }\n})\n</code></pre> <pre><code>fun TestConfig.printStart() = aroundEachTest { testAction -&gt;\n    println(\"Starting a test $this\")\n    testAction() // (1)!\n}\n\nval LifecycleHookTests by testSuite(testConfig = TestConfig.printStart()) {\n    test(\"this test should be alive\") {\n        println(\"Johnny5 is alive!\")\n    }\n}\n</code></pre> <ol> <li>You can put extra code after the test action, or surround it with a timeout function, or a try-catch, or\u2026</li> </ol> <p>Kotest has 44 mechanisms to track and influence tests:</p> <ul> <li>14 \"lifecycle hooks\",</li> <li>14 \"simple extensions\", and</li> <li>16 \"advanced extensions\".</li> </ul> <p>TestBalloon's TestConfig decorator chain provides 4 functional mechanisms which achieve the same:</p> <ul> <li>two universal functions: <code>aroundEach()</code> and <code>traversal()</code>,</li> <li>two convenience variants: <code>aroundAll()</code> and <code>aroundEachTest()</code>.</li> </ul> <p>Note</p> <p>TestBalloon's <code>TestConfig</code> wrappers can be combined and attached to any point in the test element hierarchy. <code>TestConfig</code> is a unified and composable mechanism, available for all kinds of test elements. Like the Modifiers of Jetpack Compose, this design make the API concise and flexible.</p>"},{"location":"how-to/migrating-from-kotest/#extensions","title":"Extensions","text":""},{"location":"how-to/migrating-from-kotest/#data-driven-testing","title":"Data-driven testing","text":"<p>TestBalloon uses plain Kotlin for data driven tests. There is no additional API to learn.</p> <p>If you want to keep using Kotest's data-driven testing features, or its property testing, the TestBalloon Addons library by A-SIT Plus provides both.</p>"},{"location":"how-to/migrating-from-kotlin-test/","title":"\u2026from kotlin.test","text":""},{"location":"how-to/migrating-from-kotlin-test/#keep-your-assertions","title":"Keep your assertions","text":"<p>You can keep your assertion library (most assertion libraries work out of the box, for Kotest Assertions there is a TestBalloon integration for it). Code inside tests can remain unchanged.</p>"},{"location":"how-to/migrating-from-kotlin-test/#what-needs-to-change","title":"What needs to change","text":""},{"location":"how-to/migrating-from-kotlin-test/#test-classes-and-methods","title":"Test Classes and Methods","text":"<p>Top-level test classes become top-level suite properties. Test methods become <code>test</code> function invocations:</p> kotlin.testTestBalloon <pre><code>class KotlinTestBasics {\n    @Test\n    fun expected_to_pass() {\n        assertEquals(4, 2 + 2)\n    }\n\n    @Test\n    fun expected_to_fail() {\n        assertEquals(5, 2 + 2)\n    }\n}\n</code></pre> <pre><code>val FromKotlinTestBasics by testSuite {\n    test(\"expected to pass\") {\n        assertEquals(4, 2 + 2)\n    }\n\n    test(\"expected to fail\") {\n        assertEquals(5, 2 + 2)\n    }\n}\n</code></pre>"},{"location":"how-to/migrating-from-kotlin-test/#class-properties-setup-and-teardown","title":"Class properties, setup and teardown","text":"<p>Keep your code inside tests, and</p> <ol> <li>wrap <code>kotlin.test</code> class properties into a fixture, omitting <code>var</code> and <code>lateinit</code>,</li> <li>omit <code>runTest</code>,</li> <li>co-locate setup code with initialization,</li> <li>use the optional <code>closeWith</code> lambda for tear-down code,</li> <li>make it a test-level fixture, providing a fresh value to each test:</li> </ol> kotlin.testTestBalloon <pre><code>class KotlinTestFixture {\n    private lateinit var service: WeatherService\n\n    @BeforeTest\n    fun setup() = runTest {\n        service = FakeWeatherService()\n        service.connect(token = \"TestToken\")\n    }\n\n    @AfterTest\n    fun teardown() = runTest {\n        service.disconnect()\n    }\n\n    @Test\n    fun `Temperature in Hamburg is 21_5 \u00b0C`() = runTest {\n        assertEquals(21.5, service.location(\"Hamburg\").temperature)\n    }\n\n    // more tests...\n}\n</code></pre> <pre><code>val FromKotlinTestFixture by testSuite {\n    testFixture {\n        FakeWeatherService().apply {\n            connect(token = \"TestToken\") // (1)!\n        }\n    } closeWith {\n        disconnect() // (2)!\n    } asParameterForEach { // (3)!\n\n        test(\"Temperature in Hamburg is 21.5 \u00b0C\") { service -&gt;\n            assertEquals(21.5, service.location(\"Hamburg\").temperature)\n        }\n\n        // more tests...\n    }\n}\n</code></pre> <ol> <li>As the <code>testFixture</code> lambda is suspending, you can co-locate any setup code here.</li> <li>A suspending tear-down function.</li> <li>Making it a test-level fixture provides a fresh, isolated value as a parameter for each test.</li> </ol> <p>Tip</p> <p>For a fixture with multiple properties, use an <code>object</code> expression and provide it via <code>asContextForEach</code> to each test.</p>"},{"location":"how-to/migrating-from-kotlin-test/#other","title":"Other","text":"<p>To <code>@Ignore</code> a test or suite, pass <code>testConfig = TestConfig.disable()</code> as a parameter to the <code>test</code> or <code>testSuite</code> function.</p> <p>To migrate <code>@BeforeClass</code> and <code>@AfterClass</code> (which <code>kotlin.test</code> provides on Native), see the corresponding JUnit section on sharing state across tests. </p>"},{"location":"how-to/upgrading/","title":"Upgrading","text":""},{"location":"how-to/upgrading/#upgrading-from-testballoon-07x-to-083","title":"Upgrading from TestBalloon 0.7.x to 0.8.3","text":""},{"location":"how-to/upgrading/#removal-of-deprecations","title":"Removal of deprecations","text":"<ul> <li>Replace class declarations for top-level test suites with properties.</li> <li>Change code using <code>dispatcherWithParallelism()</code>.</li> <li>Replace <code>aroundAll</code> with <code>testConfig = TestConfig.aroundAll { ... }</code>.</li> <li>Replace <code>testConfig</code> assignments in test suite bodies with <code>testSuite(..., testConfig = ...)</code>.</li> <li>Replace the <code>TEST_INCLUDE</code> environment variable with <code>TESTBALLOON_INCLUDE_PATTERNS</code>.</li> </ul>"},{"location":"how-to/upgrading/#android-host-side-unit-tests","title":"Android host-side (unit) tests","text":"<ol> <li>Remove the <code>-jvm</code> suffix from each dependency <code>\"de.infix.testBalloon:testBalloon-framework-core-jvm:$testBalloonVersion\"</code>.</li> <li>Add a dependency on JUnit 4: <code>\"junit:junit:4.13.2\"</code></li> </ol>"},{"location":"how-to/upgrading/#custom-test-functions","title":"Custom test functions","text":""},{"location":"how-to/upgrading/#use-testsuitescope-instead-of-testsuite","title":"Use <code>TestSuiteScope</code> instead of <code>TestSuite</code>","text":"<p>Change extension functions like <code>TestSuite.myCustomTest()</code> to <code>TestSuiteScope.myCustomTest()</code>. This makes them compatible with the new fixture scopes and other custom scopes.</p> <p>Note</p> <p>While this change may not be necessary initially (if you do not yet use <code>TestSuiteScope</code>), applying it right away avoids incompatibilities later on. Please change all usages.</p>"},{"location":"how-to/upgrading/#prefer-test-level-fixtures-over-custom-test-functions","title":"Prefer test-level fixtures over custom test functions","text":"<p>The following change is optional, but simplifies your code:</p> TestBalloon 0.7.xTestBalloon 0.8.3 <pre><code>testSuite(\"Multiple tests with fresh state\") {\n    @TestRegistering \n    fun test(name: String, action: suspend Service.() -&gt; Unit) = \n        this.test(name) {\n            val service = Service().apply {\n                signIn(userName = \"siobhan\", password = \"ask\") \n            }\n            service.action() \n            signOut()\n        }\n\n    test(\"deposit\") {\n        deposit(Amount(20.0)) \n        assertEquals(Amount(40.99), accountBalance()) \n    }\n\n    test(\"withdraw\") {\n        withdraw(Amount(20.0))\n        assertEquals(Amount(0.99), accountBalance())\n    }\n}\n</code></pre> <pre><code>testSuite(\"Multiple tests with fresh state\") {\n    testFixture {\n        Service().apply {\n            signIn(userName = \"siobhan\", password = \"ask\") \n        } \n    } closeWith {\n        signOut()\n    } asContextForEach {\n        test(\"deposit\") {\n            deposit(Amount(20.0))\n            assertEquals(Amount(40.99), accountBalance())\n        }\n\n        test(\"withdraw\") {\n            withdraw(Amount(20.0))\n            assertEquals(Amount(0.99), accountBalance())\n        }\n    }\n}\n</code></pre>"},{"location":"how-to/upgrading/#testconfig-changes","title":"<code>TestConfig</code> changes","text":"<ul> <li>Change <code>TestInvocation.SEQUENTIAL</code> to <code>TestConfig.Invocation.Sequential</code>.</li> <li>Change <code>TestInvocation.CONCURRENT</code> to <code>TestConfig.Invocation.Concurrent</code>.</li> <li>Change <code>TestExecutionTraversal</code> to <code>TestConfig.ExecutionTraversal</code>.</li> <li>Change <code>TestExecutionScope</code> to <code>Test.ExecutionScope</code>.</li> </ul>"},{"location":"how-to/upgrading/#other-changes","title":"Other changes","text":"<ul> <li>Change <code>TestSuite.Fixture</code> to <code>TestFixture</code>.</li> <li>Change <code>TestElementEvent</code> to <code>TestElement.Event</code>.</li> <li>Change <code>TestPermit</code> to <code>TestConfig.Permit</code>.</li> <li>Change members of <code>TestPlatform.Type</code> from SCREAMING_SNAKE_CASE to PascalCase.</li> </ul>"},{"location":"integrations/blocking-detection/","title":"Blocking Detection","text":"<p>The Blocking Detection integration helps to detect inadvertent calls of blocking code by coroutines.</p> <p>Example: Calling an I/O library function blocks a CPU-bound thread.</p> <p>Info</p> <p>Blocking detection is available exclusively on the JVM via BlockHound. In can be enabled in common code, but has no effect on non-JVM platforms.</p>"},{"location":"integrations/blocking-detection/#getting-started","title":"Getting started","text":"<ol> <li> <p>Add the integration's dependency to the common or JVM test source set:</p> <pre><code>implementation(\"de.infix.testBalloon:testBalloon-integration-blocking-detection:$testBalloonVersion\")\n</code></pre> </li> <li> <p>Use the following <code>testConfig</code> parameter at the appropriate point in your test element hierarchy:</p> <pre><code>testConfig = TestConfig.blockingDetection()\n</code></pre> </li> </ol>"},{"location":"integrations/blocking-detection/#configuration","title":"Configuration","text":"<p>By default, the Blocking Detection integration throws an error for suspicious blocking calls. To print detected blocking calls instead, use the following:</p> <pre><code>testConfig = TestConfig.blockingDetection(BlockingDetection.PRINT)\n</code></pre> <p>Blocking Detection can also be disabled:</p> <pre><code>testConfig = TestConfig.blockingDetection(BlockingDetection.DISABLED)\n</code></pre>"},{"location":"integrations/blocking-detection/#detection","title":"Detection","text":"<p>Blocking calls will be detected in coroutine threads which are expected not to block. Such threads are created by the default dispatcher as this example demonstrates:</p> <pre><code>private suspend fun blockInNonBlockingContext() {\n    withContext(Dispatchers.Default) {\n        @Suppress(\"BlockingMethodInNonBlockingContext\")\n        Thread.sleep(2)\n    }\n}\n</code></pre> <p>The BlockHound integration will by default produce an exception like this whenever it detects a blocking call:</p> <pre><code>reactor.blockhound.BlockingOperationError: Blocking call! java.lang.Thread.sleep0\n    at de.infix.testBalloon.integration.blockingDetection.TestBalloonBlockHoundIntegration.applyTo$lambda$0$0(Integration.jvm.kt:78)\n    at reactor.blockhound.BlockHound$Builder.lambda$install$8(BlockHound.java:488)\n    at reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:89)\n    at java.base/java.lang.Thread.sleep0(Thread.java)\n    at java.base/java.lang.Thread.sleep(Thread.java:509)\n</code></pre> <p>Whenever a blocking call is detected, you can</p> <ul> <li>replace the call with a non-blocking one (using a coroutine-aware library), or</li> <li>schedule the calling coroutine to run on a separate I/O thread (e.g. via <code>Dispatchers.IO</code>), or</li> <li>add an exception if the blocking is harmless (see below).</li> </ul>"},{"location":"integrations/blocking-detection/#customization","title":"Customization","text":"<p>To customize BlockHound, familiarize yourself with the BlockHound documentation.</p> <p>Exceptions for blocking calls considered harmless can be added via a separate <code>BlockHoundIntegration</code> class like this:</p> <pre><code>import reactor.blockhound.BlockHound\nimport reactor.blockhound.integration.BlockHoundIntegration\n\nclass MyBlockHoundIntegration : BlockHoundIntegration {\n    override fun applyTo(builder: BlockHound.Builder): Unit = with(builder) {\n        allowBlockingCallsInside(\"org.slf4j.LoggerFactory\", \"performInitialization\")\n    }\n}\n</code></pre> <p>In order to allow <code>BlockHound</code> to auto-detect and load the integration, add its fully qualified class name to a service provider configuration file <code>resources/META-INF/services/reactor.blockhound.integration.BlockHoundIntegration</code>.</p>"},{"location":"integrations/kotest-assertions/","title":"Kotest Assertions","text":"<p>The Kotest Assertions integration provides support for the Kotest Assertions library with its large selection of matchers.</p> <p>Info</p> <p>Some Kotest Assertions functions, like <code>assertSoftly</code> and <code>withClue</code>, require a special setup to work safely with multithreaded coroutines. This integration provides such setup.</p> <p>Otherwise, Kotest Assertions can be used out of the box without this integration.</p>"},{"location":"integrations/kotest-assertions/#getting-started","title":"Getting started","text":"<ol> <li> <p>Add the integration's dependency to the common or other test source set:</p> <pre><code>implementation(\"de.infix.testBalloon:testBalloon-integration-kotest-assertions:$testBalloonVersion\")\n</code></pre> </li> <li> <p>Use the following <code>testConfig</code> parameter at the appropriate point in your test element hierarchy, for example the <code>TestSession</code>:</p> <pre><code>testConfig = TestConfig. kotestAssertionsSupport()\n</code></pre> </li> </ol> <p>That's it. There is nothing else to configure.</p>"},{"location":"integrations/roboelectric/","title":"Roboelectric","text":"<p>The Roboelectric integration brings Roboelectric's fast, reliable and configurable Android testing to TestBalloon:</p> <ul> <li>All TestBalloon capabilities are available in Roboelectric test suites, including parameterized tests, nested test suites and test fixtures.</li> <li>The Roboelectric environment can be fully configured in plain Kotlin, using a DSL, without resorting to annotations.</li> </ul>"},{"location":"integrations/roboelectric/#getting-started","title":"Getting started","text":"<ol> <li> <p>Add the integration's dependency for Android host-side tests:</p> Kotlin Multiplatform with Android host-side testsAndroid-only host-side tests <pre><code>named(\"androidHostTest\") { // (1)!\n    dependencies {\n        implementation(\"de.infix.testBalloon:testBalloon-integration-roboelectric:$testBalloonVersion\")\n        implementation(\"junit:junit:$junit4Version\")\n    }\n}\n</code></pre> <ol> <li>Using the <code>com.android.kotlin.multiplatform.library</code> plugin.</li> </ol> <pre><code>dependencies {\n    testImplementation(\"de.infix.testBalloon:testBalloon-integration-roboelectric:$testBalloonVersion\")\n    testImplementation(\"junit:junit:$junit4Version\")\n}\n</code></pre> </li> <li> <p>Register a Roboelectric test suite with <code>roboelectricTestSuite</code>:</p> <pre><code>roboelectricTestSuite( // (1)!\n    \"API level $apiLevel\",\n    MyRoboelectricTests::class, // (2)!\n    testConfig = TestConfig.roboelectric { // (3)!\n        sdk = apiLevel\n        qualifiers = \"xlarge-port\"\n        applicationLifetime = ApplicationLifetime.RoboelectricTestSuite\n    }\n) // (4)!\n</code></pre> <ol> <li>Registers a Roboelectric test suite. This must occur inside an existing test suite.</li> <li>Specifies the class which will contain the test suite's content.</li> <li>Configure Roboelectric as desired. As usual, this can also be done higher up in TestBalloon's test element hierarchy.</li> <li>There is no trailing lambda because the test suite's content resides in a separate class.</li> </ol> </li> <li> <p>Add the Roboelectric test suite contents to a separate class derived from <code>RoboelectricTestSuiteContent</code>:</p> <pre><code>internal class MyRoboelectricTests : // (1)!\n    RoboelectricTestSuiteContent({ // (2)!\n        test(\"Application exists\") {\n            val application = getApplicationContext&lt;Application&gt;()\n            assertNotNull(application)\n        }\n\n        testSuite(\"Details\") {\n            test(\"Motion event sources are supported, but not present\") {\n                // Added in API level 34\n                assertEquals(0, AccessibilityServiceInfo().motionEventSources)\n            }\n\n            test(\"Screen size is 'xlarge'\") {\n                assertContains(RuntimeEnvironment.getQualifiers(), \"xlarge\")\n            }\n        }\n    })\n</code></pre> <ol> <li>This class will be dynamically loaded by Roboelectric's sandbox class loader.</li> <li>The <code>RoboelectricTestSuiteContent</code> base class handles all TestBalloon integration.</li> </ol> <p>Note</p> <p>Roboelectric test suites do not nest. You cannot invoke <code>roboelectricTestSuite</code> inside <code>RoboelectricTestSuiteContent</code>.</p> </li> </ol>"},{"location":"integrations/roboelectric/#configuration","title":"Configuration","text":"<p><code>TestConfig.roboelectric { ... }</code> configures all Roboelectric settings via a DSL.</p> <p>As with any other <code>TestConfig</code> configuration, Roboelectric settings can be configured at any level of the test element hierarchy, including globally. Settings are inherited, but can be overridden at lower levels.</p> <p>Note</p> <p>Settings become effective wherever a <code>roboelectricTestSuite</code> appears. Settings appearing inside a Roboelectric test suite have no effect.</p> <p><code>roboelectricTestSuite</code> has an <code>arguments</code> parameter which you can use to pass values to constructor parameters of the corresponding test suite content class.</p> <p>Info</p> <p><code>arguments</code> is the boundary where types and values travel between the \"normal\" JVM world and the Roboelectric environment. By default, Roboelectric will re-load all classes it encounters with its own sandbox class loader, making them incompatible with the \"same\" classes in the JVM world.</p> <p>To make a class <code>MyType</code> and all classes in <code>com.example.mypackage</code> portable between those worlds, add the following <code>testConfig</code> parameter to the <code>roboelectricTestSuite</code> invocation (or anywhere above it in the test element hierarchy):</p> <pre><code>testConfig = TestConfig.roboelectric {\n    portableClasses += MyType::class\n    portablePackages += \"com.example.mypackage\"\n}\n</code></pre>"},{"location":"integrations/roboelectric/#roboelectric-resources","title":"Roboelectric Resources","text":"<ul> <li>Configuring Robolectric</li> <li>Device Configuration</li> <li>Using qualified resources</li> <li>Best Practices &amp; Limitations</li> </ul>"},{"location":"overview/why/","title":"Why use TestBalloon?","text":""},{"location":"overview/why/#unique","title":"Unique","text":"<p>TestBalloon combines</p> <ul> <li> state-of-the-art capabilities(1) with</li> <li> deep native integration(2)</li> <li> on all platforms.(3)</li> </ul> <ol> <li>Parameterized tests, multi-level hierarchy, coroutine context inheritance, deep parallelism, fixtures, expressive names, and a scope-friendly DSL-based API.</li> <li>TestBalloon integrates thoroughly with the platforms' existing APIs and build tooling, using the familiar Gradle tasks and Kotlin's own platform-specific test runtimes.</li> <li>TestBalloon supports all Kotlin target platforms (JVM, JS, WebAssembly, Android host-side tests, Android device-side tests, Linux, Windows, iOS, macOS and other Apple targets).</li> </ol>"},{"location":"overview/why/#empowering","title":"Empowering","text":"<p>TestBalloon helps you lift product quality, save time and actually make testing enjoyable.</p> <ul> <li> Write better tests (parameterize them)</li> <li> with less effort (using your Kotlin skills and a simple API)</li> <li> on all platforms (with native integration that just works).</li> </ul> <p>What else?</p> <ul> <li> Stay organized (with expressive names and a multi-level hierarchy),</li> <li> get faster results (with deep parallelism in test runs),</li> <li> remain compatible (with all Kotlin releases since 2.0).</li> </ul>"},{"location":"overview/why/#robust","title":"Robust","text":"<p>TestBalloon consists of production-quality code and has been intensively tested. Its own test suite runs all component tests on all Kotlin targets, plus integration tests on all Kotlin target categories.</p>"},{"location":"overview/why/#fast","title":"Fast","text":"<p>TestBalloon can cover large test sets and has been observed running 1.7 million real-world tests in 86 seconds on a Framework 13 Laptop (18 cores, 4 GB JVM heap) with concurrent execution enabled.</p>"},{"location":"overview/why/#production-ready","title":"Production-ready","text":"<p>TestBalloon is actively used in production.</p> <p>Open source products using TestBalloon include:</p> <ul> <li> Prepared \u2013 a Kotlin Multiplatform test library featuring time management, parameterization and isolated fixtures</li> <li> Signum \u2013 a Kotlin Multiplatform crypto/PKI library and ASN1 parser + encoder</li> <li> VC-K \u2013 a verifiable credentials library for Kotlin Multiplatform</li> <li> Warden Supreme \u2013 an integrated key and app attestation suite</li> </ul> <p>Of course, advanced testing is often found in closed-source products, and TestBalloon is in active use there as well.</p>"},{"location":"overview/why/#stability","title":"Stability","text":"<p>TestBalloon has a stable feature set. However, it is still evolving, so you should expect some migration issues. Breaking changes will be documented in the release notes, along with migration guidance.</p>"},{"location":"overview/why/#why-wait","title":"Why wait?","text":"<p>TestBalloon is your trouble reducer and helps you release with confidence.</p> <ul> <li> Powerful multiplatform testing made easy.</li> <li> Test more (edge) cases with less effort.</li> <li> Keep your AI-generated code in check.</li> </ul>"},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/archive/2025/","title":"2025","text":""}]}