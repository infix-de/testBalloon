@file:Suppress("NewApi")
@file:OptIn(TestBalloonInternalApi::class)

package de.infix.testBalloon.gradlePlugin.shared

import de.infix.testBalloon.framework.shared.internal.Constants
import de.infix.testBalloon.framework.shared.internal.EnvironmentVariable
import de.infix.testBalloon.framework.shared.internal.ReportingMode
import de.infix.testBalloon.framework.shared.internal.TestBalloonInternalApi
import org.gradle.api.Project
import org.gradle.api.internal.tasks.testing.filter.DefaultTestFilter
import org.gradle.api.tasks.testing.AbstractTestTask
import org.gradle.api.tasks.testing.Test
import org.jetbrains.kotlin.gradle.dsl.KotlinBaseExtension
import org.jetbrains.kotlin.gradle.targets.js.testing.KotlinJsTest
import org.jetbrains.kotlin.gradle.targets.native.tasks.KotlinNativeTest
import org.jetbrains.kotlin.gradle.testing.internal.KotlinTestReport
import java.nio.file.DirectoryNotEmptyException
import kotlin.io.path.Path
import kotlin.io.path.deleteIfExists
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.writeText

/**
 * Configures the project for TestBalloon, given the precondition that the compiler plugin artifacts are set up.
 */
internal fun Project.configureWithTestBalloon(
    testBalloonProperties: TestBalloonGradleProperties,
    browserSafeEnvironmentPatternFromExtension: () -> String = { "" }
) {
    addEntryPointSourceFile(testBalloonProperties)
    configureTestTasks(testBalloonProperties, browserSafeEnvironmentPatternFromExtension)
}

/**
 * Adds TestBalloon's entry point source file to all test root source sets (such as "commonTest").
 */
private fun Project.addEntryPointSourceFile(testBalloonProperties: TestBalloonGradleProperties) {
    val generateTestBalloonEntryPointTask = tasks.register("generateTestBalloonEntryPoint") {
        val generatedCommonTestDir = layout.buildDirectory.dir("generated/testBalloon/src/commonTest")
        outputs.dir(generatedCommonTestDir)
        doLast {
            val directory = Path("${generatedCommonTestDir.get()}/kotlin")
            check(directory.exists() || directory.toFile().mkdirs()) { "Could not create directory '$directory'" }
            (directory / Constants.ENTRY_POINT_ANCHOR_FILE_NAME).writeText(
                """
                        package ${Constants.ENTRY_POINT_PACKAGE_NAME}

                        // This file was generated by the TestBalloon Gradle plugin.
                        // The compiler plugin will populate it with entry point code. 

                """.trimIndent()
            )
        }
    }

    afterEvaluate {
        // Why use afterEvaluate at this point?
        // In order to reliably detect all test root source sets, we must be sure that the source set hierarchy
        // has been completely set up. Otherwise, `dependsOn.isEmpty()` would detect false positives.
        //
        // What are the expected failure modes of using `afterEvaluate` (as described
        // in https://www.liutikas.net/2022/12/09/Evaluate-Your-AfterEvaluate.html)?
        // - If another plugin modifies the source set hierarchy in an `afterEvaluate` block, its modifications might
        //   not be picked up, depending on the order plugins are applied to the project.

        extensions.configure<KotlinBaseExtension>("kotlin") {
            val testRootSourceSetRegex = testBalloonProperties.testRootSourceSetRegex
            sourceSets.configureEach {
                if (testRootSourceSetRegex.containsMatchIn(name) && dependsOn.isEmpty()) {
                    kotlin.srcDir(generateTestBalloonEntryPointTask)
                }
            }
        }
    }
}

/**
 * Configures the test tasks for TestBalloon.
 */
private fun Project.configureTestTasks(
    testBalloonProperties: TestBalloonGradleProperties,
    browserSafeEnvironmentPatternFromExtension: () -> String
) {
    val reportingMode = when (testBalloonProperties.reportingMode) {
        "intellij" -> ReportingMode.INTELLIJ_IDEA
        "files" -> ReportingMode.FILES
        else -> if (providers.systemProperty("idea.active").isPresent) {
            ReportingMode.INTELLIJ_IDEA
        } else {
            ReportingMode.FILES
        }
    }

    val reportsEnabled = testBalloonProperties.reportsEnabled ?: (reportingMode == ReportingMode.FILES)

    if (!reportsEnabled) {
        tasks.withType(AbstractTestTask::class.java).configureEach {
            reports.html.required.set(false)
            reports.junitXml.required.set(false)
        }
        tasks.withType(KotlinTestReport::class.java).configureEach {
            enabled = false
        }
    }

    tasks.withType(Test::class.java).configureEach {
        // https://docs.gradle.org/current/userguide/java_testing.html
        useJUnitPlatform()

        // Ask Gradle to skip scanning for test classes. We don't need it as our compiler plugin already
        // knows. Does this make a difference? I don't know.
        isScanForTestClasses = false
    }

    val browserTestTaskRegex = testBalloonProperties.browserTestTaskRegex

    val reportingPathLimit =
        providers.environmentVariable(EnvironmentVariable.TESTBALLOON_REPORTING_PATH_LIMIT.name).orNull?.ifEmpty {
            null
        }
            ?: testBalloonProperties.reportingPathLimit?.toString()

    gradle.taskGraph.whenReady {
        // Why use `taskGraph.whenReady` at this point?
        // We want to
        // 1. access the test patterns provided by `AbstractTestTask.filter` options and `--tests` command line
        //    arguments, and
        // 2. mutate the test task to populate an environment variable or Karma configuration file with those patterns.
        //
        // What are the expected failure modes of using `taskGraph.whenReady`?
        // - If another plugin modifies test-related parameters in a `taskGraph.whenReady` block, they might not be
        //   picked up, depending on the order plugins are applied to the project.

        tasks.withType(AbstractTestTask::class.java).configureEach {
            /**
             * Resets Gradle test-filtering patterns.
             *
             * This prevents using the original patterns to filter in ways which are incompatible with TestBalloon's
             * own include/exclude patterns on JS (by Mocha) and the JVM (by JUnit Platform).
             */
            fun resetGradleTestFiltering() {
                if (testBalloonProperties.testFilteringResetEnabled == true) {
                    (filter as DefaultTestFilter).commandLineIncludePatterns.clear()
                    filter.includePatterns.clear()
                    filter.excludePatterns.clear()
                    // Avoid Gradle error
                    //    "...no filters are applied, but the test task did not discover any tests to execute."
                    if (hasProperty("failOnNoDiscoveredTests")) {
                        setProperty("failOnNoDiscoveredTests", false)
                    }
                }
            }

            fun testBalloonEnvironment(
                secondaryIncludePatterns: List<String>,
                secondaryExcludePatterns: List<String>
            ): Map<String, String> = buildMap {
                fun prioritizedPatterns(vararg primary: EnvironmentVariable, secondary: Iterable<String>): String =
                    primary.firstNotNullOfOrNull { System.getenv(it.name)?.ifEmpty { null } }
                        ?: secondary.joinToString("${Constants.INTERNAL_PATH_PATTERN_SEPARATOR}")

                this[EnvironmentVariable.TESTBALLOON_INCLUDE_PATTERNS.name] =
                    prioritizedPatterns(
                        EnvironmentVariable.TESTBALLOON_INCLUDE_PATTERNS,
                        EnvironmentVariable.TEST_INCLUDE,
                        secondary = secondaryIncludePatterns
                    )

                this[EnvironmentVariable.TESTBALLOON_EXCLUDE_PATTERNS.name] =
                    prioritizedPatterns(
                        EnvironmentVariable.TESTBALLOON_EXCLUDE_PATTERNS,
                        secondary = secondaryExcludePatterns
                    )

                this[EnvironmentVariable.TESTBALLOON_REPORTING.name] = reportingMode.name
                if (reportingPathLimit != null) {
                    this[EnvironmentVariable.TESTBALLOON_REPORTING_PATH_LIMIT.name] = reportingPathLimit
                }
            }

            fun KotlinJsTest.configureKarmaEnvironment() {
                val directory = Path("${layout.projectDirectory}") / "karma.config.d"
                val parameterConfigFile = directory / "testBalloonParameters.js"

                val secondaryIncludePatterns = (
                    filter.includePatterns + (filter as DefaultTestFilter).commandLineIncludePatterns
                    ).toList()
                val secondaryExcludePatterns = filter.excludePatterns.toList()

                resetGradleTestFiltering()

                val browserSafeEnvironmentPatternStrings = listOf(
                    testBalloonProperties.browserSafeEnvironmentPattern,
                    browserSafeEnvironmentPatternFromExtension()
                )

                doFirst {
                    @Suppress("NewApi")
                    check(directory.exists() || directory.toFile().mkdirs()) {
                        "Could not create directory '$directory'"
                    }

                    val browserSafeEnvironmentPatterns = browserSafeEnvironmentPatternStrings.mapNotNull {
                        if (it.isEmpty()) null else it.toRegex()
                    }

                    // The environment propagated to the browser. TestBalloon's own entries have precedence.
                    val browserEnvironment =
                        System.getenv().filter { (name, _) ->
                            browserSafeEnvironmentPatterns.any { it.matches(name) }
                        } + testBalloonEnvironment(secondaryIncludePatterns, secondaryExcludePatterns)

                    val clientConfiguration = buildList {
                        add("config.client = config.client || {};")
                        add("config.client.env = {")

                        add(
                            browserEnvironment.map { (name, value) ->
                                val escapedValue = value
                                    .replace("\\", "\\\\")
                                    .replace("\"", "\\\"")
                                    .filter { it.code >= 0x20 }
                                """    $name: "$escapedValue""""
                            }.joinToString(separator = ",\n")
                        )

                        add("}")
                    }

                    parameterConfigFile.writeText(clientConfiguration.joinToString(separator = "\n"))
                }

                doLast {
                    @Suppress("NewApi")
                    if (parameterConfigFile.deleteIfExists()) {
                        try {
                            directory.deleteIfExists()
                        } catch (_: DirectoryNotEmptyException) {
                        }
                    }
                }
            }

            /**
             * Invokes [setTestEnvironment] to set up TestBalloon environment variables.
             */
            fun AbstractTestTask.configureEnvironment(setTestEnvironment: (name: String, value: String) -> Unit) {
                val secondaryIncludePatterns = (
                    filter.includePatterns + (filter as DefaultTestFilter).commandLineIncludePatterns
                    ).toList()
                val secondaryExcludePatterns = filter.excludePatterns.toList()

                resetGradleTestFiltering()

                doFirst {
                    for ((name, value) in testBalloonEnvironment(secondaryIncludePatterns, secondaryExcludePatterns)) {
                        setTestEnvironment(name, value)
                    }
                }
            }

            when (this) {
                is KotlinNativeTest -> {
                    configureEnvironment { name, value ->
                        environment(name, value, false)
                    }
                }

                is KotlinJsTest -> {
                    if (browserTestTaskRegex.containsMatchIn(name)) {
                        configureKarmaEnvironment()
                    } else {
                        configureEnvironment { name, value ->
                            environment(name, value)
                        }
                    }
                }

                is Test -> {
                    configureEnvironment { name, value ->
                        environment(name, value)
                    }
                }
            }
        }
    }
}
